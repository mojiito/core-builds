{"version":3,"file":"core.umd.js","sources":["../../../../packages/core/public_api.ts","../../../../packages/core/src/core.ts","../../../../packages/core/src/di/injection_token.ts","../../../../packages/core/src/view/view_ref.ts","../../../../packages/core/src/view/refs.ts","../../../../packages/core/src/view/utils.ts","../../../../packages/core/src/view/view_attach.ts","../../../../packages/core/src/view/view.ts","../../../../packages/core/src/view/provider.ts","../../../../packages/core/src/view/view_container_ref.ts","../../../../packages/core/src/view/element_ref.ts","../../../../packages/core/src/render.ts","../../../../packages/core/src/component/reference.ts","../../../../packages/core/src/application/application.ts","../../../../packages/core/src/component/factory.ts","../../../../packages/core/src/component/factory_resolver.ts","../../../../packages/core/src/application/platform.ts","../../../../packages/core/src/di/reflective_injector.ts","../../../../packages/core/src/di/reflective_provider.ts","../../../../packages/core/src/di/reflective_key.ts","../../../../packages/core/src/di/forward_ref.ts","../../../../packages/core/src/di/reflective_errors.ts","../../../../packages/core/src/di/injector.ts","../../../../packages/core/src/application/platform_errors.ts","../../../../packages/core/src/facade/error.ts","../../../../packages/core/src/component/resolver.ts","../../../../packages/core/src/reflection/reflector.ts","../../../../packages/core/src/reflection/reflection.ts","../../../../packages/core/src/reflection/reflection_capabilities.ts","../../../../packages/core/src/type.ts","../../../../packages/core/src/component/metadata.ts","../../../../packages/core/src/utils/decorator.ts","../../../../packages/core/src/facade/lang.ts","../../../../packages/core/src/facade/collection.ts"],"sourcesContent":["/**\n * @module\n * @description\n * Entry point for all public APIs of the core package.\n */\nexport {createPlatformFactory,getPlatform,PlatformRef,ApplicationRef,Component,HostListener,ChildListener,ComponentResolver,ComponentFactory,ComponentFactoryResolver,ComponentRef,createComponentFactory,ViewRef,ViewContainerRef,ElementRef,createViewDefinitionFactory,createView,forwardRef,InjectionToken,Injector,Host,Inject,Injectable,Optional,Self,SkipSelf,Provider,ClassProvider,ExistingProvider,FactoryProvider,TypeProvider,ValueProvider,ReflectiveInjector,ReflectiveInjector_,ReflectiveKey,ReflectiveDependency,ResolvedReflectiveFactory,ResolvedReflectiveProvider,ResolvedReflectiveProvider_,resolveReflectiveProviders,mergeResolvedReflectiveProviders,constructDependencies,reflector,ReflectorReader,Reflector,ClassType,Type,Renderer,RendererFactory,RendererType,Visitor,CORE_PROVIDERS,NodeDef,ProviderDef,DepDef,DepFlags,ProviderData,asProviderData,ViewDefinition,ViewDefinitionFactory,NodeData,ViewData,ViewState,ViewContainerData,DisposableFn,RootData,NodeFlags} from './src/core';\n","import { ComponentResolver } from './component/resolver';\nimport { reflector, Reflector } from './reflection/reflection';\nimport { ReflectorReader } from './reflection/reflector_reader';\nimport {\n  Provider, ClassProvider, ExistingProvider,\n  FactoryProvider, TypeProvider, ValueProvider,\n} from './di/provider';\n\n// Platform & Application\nexport { createPlatformFactory, getPlatform, PlatformRef } from './application/platform';\nexport { ApplicationRef } from './application/application';\n\n// Component\nexport { Component, HostListener, ChildListener } from './component/metadata';\nexport { ComponentResolver };\nexport { ComponentFactory } from './component/factory';\nexport { ComponentFactoryResolver } from './component/factory_resolver';\nexport { ComponentRef } from './component/reference';\n\n// View\nexport { createComponentFactory } from './view/refs';\nexport {NodeDef,ProviderDef,DepDef,DepFlags,ProviderData,asProviderData,ViewDefinition,ViewDefinitionFactory,NodeData,ViewData,ViewState,ViewContainerData,DisposableFn,RootData,NodeFlags} from './view/types';\nexport { ViewRef } from './view/view_ref';\nexport { ViewContainerRef } from './view/view_container_ref';\nexport { ElementRef } from './view/element_ref';\nexport { createViewDefinitionFactory, createView } from './view/view';\n\n// Dependency Injection\nexport { forwardRef } from './di/forward_ref';\nexport { InjectionToken } from './di/injection_token';\nexport { Injector } from './di/injector';\nexport { Host, Inject, Injectable, Optional, Self, SkipSelf } from './di/metadata';\nexport {\n  Provider, ClassProvider, ExistingProvider,\n  FactoryProvider, TypeProvider, ValueProvider\n};\nexport { ReflectiveInjector, ReflectiveInjector_ } from './di/reflective_injector';\nexport { ReflectiveKey } from './di/reflective_key';\nexport {\n  ReflectiveDependency, ResolvedReflectiveFactory, ResolvedReflectiveProvider,\n  ResolvedReflectiveProvider_, resolveReflectiveProviders, mergeResolvedReflectiveProviders,\n  constructDependencies\n} from './di/reflective_provider';\nexport { reflector, ReflectorReader, Reflector };\n\n// Others\nexport { ClassType, Type } from './type';\nexport { Renderer, RendererFactory, RendererType, Visitor } from './render';\n\n// Providers\nexport const /** @type {?} */ CORE_PROVIDERS: Provider[] = [\n  { provide: ReflectorReader, useValue: reflector },\n  ComponentResolver\n];\n","\n/**\n * Creates a token that can be used in a DI Provider.\n * \n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parametrized type.\n * \n * `InjectionToken` is parametrize on `T` which is the type of object which will be returned by the\n * `Injector`. This provides additional level of type safety.\n * \n * ```\n * interface MyInterface {...}\n * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\n * // myInterface is inferred to be MyInterface.\n * ```\n * \n * ### Example\n * \n * {\\@example core/di/ts/injector_spec.ts region='Injector'}\n * \n * \\@stable\n */\nexport class InjectionToken<T> {\n/**\n * @param {?} _desc\n */\nconstructor(protected _desc: string) {}\n/**\n * @return {?}\n */\ntoString(): string { return `InjectionToken ${this._desc}`; }\n}\n\nfunction InjectionToken_tsickle_Closure_declarations() {\n/** @type {?} */\nInjectionToken.prototype._desc;\n}\n\n","import { ApplicationRef } from '../application/application';\n/**\n * @abstract\n */\nexport abstract class ViewRef {\n/**\n * Destroys the view and all of the data structures associated with it.\n * @abstract\n * @return {?}\n */\ndestroy() {}\n/**\n * @abstract\n * @return {?}\n */\ndestroyed() {}\n/**\n * @abstract\n * @param {?} callback\n * @return {?}\n */\nonDestroy(callback: Function) {}\n\n}\n\nexport interface InternalViewRef extends ViewRef {\n  detachFromAppRef(): void;\n  attachToAppRef(appRef: ApplicationRef): void;\n}\n","// tslint:disable:class-name\n\nimport { ClassType } from '../type';\nimport { ApplicationRef } from '../application/application';\nimport { Renderer } from '../render';\nimport { Injector } from '../di/injector';\nimport { ComponentRef } from '../component/reference';\nimport { ComponentFactory } from '../component/factory';\nimport { createRootView, destroyView, initView } from './view';\nimport { ViewRef, InternalViewRef } from './view_ref';\nimport { ViewContainerRef } from './view_container_ref';\nimport { attachEmbeddedView, detachEmbeddedView } from './view_attach';\nimport { ElementRef } from './element_ref';\nimport {\n  ViewData, ViewDefinitionFactory, ViewDefinition, ViewState,\n  asProviderData, DepFlags, ViewContainerData\n} from './types';\nimport { resolveViewDefinition } from './utils';\nimport { resolveDep, tokenKey } from './provider';\n\nconst /** @type {?} */ EMPTY_CONTEXT = new Object();\n/**\n * @param {?} view\n * @return {?}\n */\nexport function createInjector(view: ViewData): Injector {\n  return new Injector_(view);\n}\n/**\n * Internal ComponentFactory\n */\nclass ComponentFactory_ extends ComponentFactory<any> {\n/**\n * @param {?} selector\n * @param {?} componentType\n * @param {?} _viewDefFactory\n */\nconstructor(public selector: string,\npublic componentType: ClassType<any>,\nprivate _viewDefFactory: ViewDefinitionFactory) {\n    super();\n  }\n/**\n * @param {?} injector\n * @param {?=} rootSelectorOrNode\n * @return {?}\n */\ncreate(injector: Injector, rootSelectorOrNode?: string | any): ComponentRef<any> {\n    const /** @type {?} */ viewDef = resolveViewDefinition(this._viewDefFactory);\n    const /** @type {?} */ componentNodeIndex = viewDef.componentProvider.index;\n    const /** @type {?} */ view = createRootView(viewDef, injector, rootSelectorOrNode, EMPTY_CONTEXT);\n    const /** @type {?} */ component = asProviderData(view, componentNodeIndex).instance;\n    return new ComponentRef_(view, new ViewRef_(view), component);\n  }\n}\n\nfunction ComponentFactory__tsickle_Closure_declarations() {\n/** @type {?} */\nComponentFactory_.prototype.selector;\n/** @type {?} */\nComponentFactory_.prototype.componentType;\n/** @type {?} */\nComponentFactory_.prototype._viewDefFactory;\n}\n\n/**\n * @param {?} selector\n * @param {?} componentType\n * @param {?} viewDefFactory\n * @return {?}\n */\nexport function createComponentFactory(selector: string, componentType: ClassType<any>,\n  viewDefFactory: ViewDefinitionFactory): ComponentFactory<any> {\n  return new ComponentFactory_(selector, componentType, viewDefFactory);\n}\n/**\n * Internal ComponentRef\n */\nclass ComponentRef_ extends ComponentRef<any> {\n/**\n * @param {?} _view\n * @param {?} _viewRef\n * @param {?} _component\n */\nconstructor(private _view: ViewData,\nprivate _viewRef: ViewRef,\nprivate _component: any) {\n    super();\n  }\n/**\n * @return {?}\n */\nget location(): ElementRef { return new ElementRef(null); }\n/**\n * @return {?}\n */\nget injector(): Injector { return new Injector_(this._view); }\n/**\n * @return {?}\n */\nget instance(): any { return this._component; };\n/**\n * @return {?}\n */\nget hostView(): ViewRef { return this._viewRef; };\n/**\n * @return {?}\n */\nget componentType(): ClassType<any> { return /** @type {?} */(( <any>this._component.constructor)); }\n/**\n * @return {?}\n */\ndestroy(): void { this._viewRef.destroy(); }\n/**\n * @param {?} callback\n * @return {?}\n */\nonDestroy(callback: Function): void { this._viewRef.onDestroy(callback); }\n}\n\nfunction ComponentRef__tsickle_Closure_declarations() {\n/** @type {?} */\nComponentRef_.prototype._view;\n/** @type {?} */\nComponentRef_.prototype._viewRef;\n/** @type {?} */\nComponentRef_.prototype._component;\n}\n\n/**\n * Internal ViewContainerRef\n */\nclass ViewContainerRef_ implements ViewContainerData {\n\n  /* @internal */\n  _embeddedViews: ViewData[] = [];\n/**\n * @param {?} _view\n */\nconstructor(private _view: ViewData) { }\n/**\n * @return {?}\n */\nget anchorElement(): ElementRef { return new ElementRef(this._view.renderElement); }\n/**\n * @return {?}\n */\nget injector(): Injector { return new Injector_(this._view); }\n/**\n * @return {?}\n */\nget parentInjector(): Injector {\n    let /** @type {?} */ view = this._view;\n    let /** @type {?} */ def = view.def;\n    while (!def && view) {\n      view = view.parent;\n      def = view.def;\n    }\n    return view ? new Injector_(view) : this._view.root.injector;\n  }\n/**\n * @return {?}\n */\nclear(): void { }\n/**\n * @param {?} index\n * @return {?}\n */\nget(index: number): ViewRef {\n    const /** @type {?} */ view = this._embeddedViews[index];\n    if (view) {\n      const /** @type {?} */ ref = new ViewRef_(view);\n      ref.attachToViewContainerRef(this);\n      return ref;\n    }\n    return null;\n  }\n/**\n * @return {?}\n */\nget length(): number { return 0; }\n/**\n * @template C\n * @param {?} templateRef\n * @param {?=} context\n * @param {?=} index\n * @return {?}\n */\ncreateEmbeddedView<C>(templateRef: any, context?: C, index?: number):\n    any { }\n/**\n * @template C\n * @param {?} componentFactory\n * @param {?=} index\n * @param {?=} injector\n * @param {?=} rootSelectorOrNode\n * @return {?}\n */\ncreateComponent<C>(componentFactory: ComponentFactory<C>, index?: number, injector?: Injector,\n    rootSelectorOrNode?: any): ComponentRef<C> {\n    const /** @type {?} */ contextInjector = injector || this.parentInjector;\n    const /** @type {?} */ componentRef = componentFactory.create(contextInjector, rootSelectorOrNode);\n    this.insert(componentRef.hostView, index);\n    return componentRef;\n  }\n/**\n * @param {?} viewRef\n * @param {?=} index\n * @return {?}\n */\ninsert(viewRef: ViewRef, index?: number): ViewRef {\n    // tslint:disable-next-line:variable-name\n    const /** @type {?} */ viewRef_ = /** @type {?} */(( <ViewRef_>viewRef));\n    const /** @type {?} */ viewData = viewRef_._view;\n    attachEmbeddedView(this._view, index, viewData);\n    viewRef_.attachToViewContainerRef(this);\n    return viewRef;\n  }\n/**\n * @param {?} viewRef\n * @return {?}\n */\nindexOf(viewRef: ViewRef): number {\n    return this._embeddedViews.indexOf(( /** @type {?} */((<ViewRef_>viewRef)))._view);\n  }\n/**\n * @param {?=} index\n * @return {?}\n */\nremove(index?: number): void {\n    const /** @type {?} */ view = detachEmbeddedView(this._view, index);\n    if (view) {\n      destroyView(view);\n    }\n  }\n/**\n * @param {?=} index\n * @return {?}\n */\ndetach(index?: number): ViewRef {\n    const /** @type {?} */ view = detachEmbeddedView(this._view, index);\n    return view ? new ViewRef_(view) : null;\n  }\n}\n\nfunction ViewContainerRef__tsickle_Closure_declarations() {\n/** @type {?} */\nViewContainerRef_.prototype._embeddedViews;\n/** @type {?} */\nViewContainerRef_.prototype._view;\n}\n\n/**\n * @param {?} view\n * @return {?}\n */\nexport function createViewContainerData(view: ViewData): ViewContainerData {\n  return new ViewContainerRef_(view);\n}\n/**\n * Internal View Reference\n */\nclass ViewRef_ implements InternalViewRef {\n  _view: ViewData;\nprivate _viewContainerRef: ViewContainerRef;\nprivate _appRef: ApplicationRef;\n/**\n * @param {?} _view\n */\nconstructor(_view: ViewData) {\n    this._view = _view;\n    this._viewContainerRef = null;\n    this._appRef = null;\n  }\n/**\n * @return {?}\n */\nget context() { return this._view.context; }\n/**\n * @return {?}\n */\nget destroyed(): boolean { return (this._view.state & ViewState.Destroyed) !== 0; }\n/**\n * @return {?}\n */\ndetach(): void { this._view.state &= ~ViewState.ChecksEnabled; }\n/**\n * @return {?}\n */\nreattach(): void { this._view.state |= ViewState.ChecksEnabled; }\n/**\n * @param {?} callback\n * @return {?}\n */\nonDestroy(callback: Function) {\n    if (!this._view.disposables) {\n      this._view.disposables = [];\n    }\n    this._view.disposables.push( /** @type {?} */((<any>callback)));\n  }\n/**\n * @return {?}\n */\ndestroy() {\n    if (this._appRef) {\n      this._appRef.detachView(this);\n    } else if (this._viewContainerRef) {\n      this._viewContainerRef.detach(this._viewContainerRef.indexOf(this));\n    }\n    destroyView(this._view);\n  }\n/**\n * @return {?}\n */\ndetachFromAppRef() {\n    this._appRef = null;\n  }\n/**\n * @param {?} appRef\n * @return {?}\n */\nattachToAppRef(appRef: ApplicationRef) {\n    if (this._viewContainerRef) {\n      throw new Error('This view is already attached to a ViewContainer!');\n    }\n    this._appRef = appRef;\n  }\n/**\n * @param {?} vcRef\n * @return {?}\n */\nattachToViewContainerRef(vcRef: ViewContainerRef) {\n    if (this._appRef) {\n      throw new Error('This view is already attached directly to the ApplicationRef!');\n    }\n    this._viewContainerRef = vcRef;\n  }\n}\n\nfunction ViewRef__tsickle_Closure_declarations() {\n/** @type {?} */\nViewRef_.prototype._view;\n/** @type {?} */\nViewRef_.prototype._viewContainerRef;\n/** @type {?} */\nViewRef_.prototype._appRef;\n}\n\n/**\n * Internal View Injector\n */\nclass Injector_ implements Injector {\n/**\n * @param {?} _view\n */\nconstructor(private _view: ViewData) { }\n/**\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget(token: any, notFoundValue: any = Injector.THROW_IF_NOT_FOUND): any {\n    return resolveDep(this._view,\n      {flags: DepFlags.None, token, tokenKey: tokenKey(token)}, notFoundValue);\n  }\n}\n\nfunction Injector__tsickle_Closure_declarations() {\n/** @type {?} */\nInjector_.prototype._view;\n}\n\n","import { Injector } from '../di/injector';\nimport { ViewDefinition, ViewDefinitionFactory, ViewData } from './types';\nimport { createInjector } from './refs';\n\nconst /** @type {?} */ VIEW_DEFINITION_CACHE = new WeakMap<any, ViewDefinition>();\n/**\n * @param {?} factory\n * @return {?}\n */\nexport function resolveViewDefinition(factory: ViewDefinitionFactory): ViewDefinition {\n  let /** @type {?} */ value: ViewDefinition = VIEW_DEFINITION_CACHE.get(factory);\n  if (!value) {\n    value = factory();\n    VIEW_DEFINITION_CACHE.set(factory, value);\n  }\n  return value;\n}\n","import { ViewData } from './types';\n/**\n * @param {?} parentView\n * @param {?} viewIndex\n * @param {?} view\n * @return {?}\n */\nexport function attachEmbeddedView(parentView: ViewData, viewIndex: number, view: ViewData) {\n  let /** @type {?} */ embeddedViews = parentView.viewContainer._embeddedViews;\n  if (viewIndex == null) {\n    viewIndex = embeddedViews.length;\n  }\n  view.viewContainerParent = parentView;\n  addToArray(embeddedViews, viewIndex, view);\n}\n/**\n * @param {?} parent\n * @param {?} viewIndex\n * @return {?}\n */\nexport function detachEmbeddedView(parent: ViewData, viewIndex: number): ViewData {\n  const /** @type {?} */ embeddedViews = parent.viewContainer._embeddedViews;\n  if (viewIndex == null || viewIndex >= embeddedViews.length) {\n    viewIndex = embeddedViews.length - 1;\n  }\n  if (viewIndex < 0) {\n    return null;\n  }\n  const /** @type {?} */ view = embeddedViews[viewIndex];\n  view.viewContainerParent = undefined;\n  removeFromArray(embeddedViews, viewIndex);\n  return view;\n}\n/**\n * @param {?} arr\n * @param {?} index\n * @param {?} value\n * @return {?}\n */\nfunction addToArray(arr: any[], index: number, value: any) {\n  // perf: array.push is faster than array.splice!\n  if (index >= arr.length) {\n    arr.push(value);\n  } else {\n    arr.splice(index, 0, value);\n  }\n}\n/**\n * @param {?} arr\n * @param {?} index\n * @return {?}\n */\nfunction removeFromArray(arr: any[], index: number) {\n  // perf: array.pop is faster than array.splice!\n  if (index >= arr.length - 1) {\n    arr.pop();\n  } else {\n    arr.splice(index, 1);\n  }\n}\n","import { Renderer, RendererFactory, RendererType } from '../render';\nimport { ComponentRef } from '../component/reference';\nimport { Injector } from '../di/injector';\nimport { Provider } from '../di/provider';\nimport { resolveReflectiveProviders } from '../di/reflective_provider';\nimport { ClassType } from '../type';\nimport { ViewContainerRef } from './view_container_ref';\nimport {\n  ViewData, ViewState, RootData, ViewDefinition, NodeFlags, ProviderData,\n  NodeData\n} from './types';\nimport { tokenKey, createProviderInstance } from './provider';\nimport { createViewContainerData } from './refs';\n/**\n * @param {?} def\n * @param {?} injector\n * @param {?} rootSelectorOrNode\n * @param {?=} context\n * @return {?}\n */\nexport function createRootView(def: ViewDefinition, injector: Injector,\n  rootSelectorOrNode: string | any, context?: any): ViewData {\n  const /** @type {?} */ rendererFactory: RendererFactory = injector.get(RendererFactory);\n  const /** @type {?} */ root = createRootData(injector, rendererFactory, rootSelectorOrNode);\n  const /** @type {?} */ view = createView(root, null, root.element, def);\n  view.renderer.parse(view);\n  return view;\n}\n/**\n * @param {?} root\n * @param {?} parent\n * @param {?} renderElement\n * @param {?} def\n * @return {?}\n */\nexport function createView(root: RootData,\n  parent: ViewData, renderElement: any, def: ViewDefinition): ViewData {\n  const /** @type {?} */ nodes: NodeData[] = new Array(def.nodes.length);\n  const /** @type {?} */ view: ViewData = {\n    def,\n    renderElement,\n    root,\n    renderer: createRenderer(renderElement, def, parent, root),\n    nodes,\n    parent,\n    viewContainerParent: undefined,\n    viewContainer: undefined,\n    context: undefined,\n    component: undefined,\n    state: ViewState.FirstCheck | ViewState.ChecksEnabled,\n    disposables: undefined,\n  };\n  if (def.nodeFlags & NodeFlags.TypeComponent) {\n    view.viewContainer = createViewContainerData(view);\n  }\n  createViewNodes(view);\n  return view;\n}\n/**\n * @param {?} view\n * @param {?} component\n * @param {?} context\n * @return {?}\n */\nexport function initView(view: ViewData, component: any, context: any) {\n  view.component = component;\n  view.context = context;\n}\n/**\n * @param {?} view\n * @return {?}\n */\nexport function destroyView(view: ViewData) {\n  if (view.state & ViewState.Destroyed) {\n    return;\n  }\n  // execEmbeddedViewsAction(view, ViewAction.Destroy);\n  // execComponentViewsAction(view, ViewAction.Destroy);\n  // callLifecycleHooksChildrenFirst(view, NodeFlags.OnDestroy);\n  if (view.disposables) {\n    for (let /** @type {?} */ i = 0; i < view.disposables.length; i++) {\n      view.disposables[i]();\n    }\n  }\n  destroyViewNodes(view);\n  view.renderer.destroy();\n  view.state |= ViewState.Destroyed;\n}\n/**\n * @param {?} view\n * @return {?}\n */\nfunction createViewNodes(view: ViewData) {\n  const /** @type {?} */ def = view.def;\n  const /** @type {?} */ nodes = view.nodes;\n  let /** @type {?} */ nodeData: any;\n  for (let /** @type {?} */ i = 0; i < def.nodes.length; i++) {\n    const /** @type {?} */ nodeDef = def.nodes[i];\n    switch (nodeDef.flags & NodeFlags.Types) {\n      case NodeFlags.TypeProvider: {\n        const /** @type {?} */ instance = createProviderInstance(view, nodeDef);\n        nodeData = /** @type {?} */(( <ProviderData>{ instance }));\n        break;\n      }\n      case NodeFlags.TypeComponent: {\n        const /** @type {?} */ instance = createProviderInstance(view, nodeDef);\n        nodeData = /** @type {?} */(( <ProviderData>{ instance }));\n\n        initView(view, instance, instance);\n        break;\n      }\n    }\n    nodes[i] = nodeData;\n  }\n}\n/**\n * @param {?} view\n * @return {?}\n */\nfunction destroyViewNodes(view: ViewData) {\n  view.renderer.destroyNode(view.renderElement);\n}\n/**\n * @param {?} injector\n * @param {?} rendererFactory\n * @param {?} rootSelectorOrNode\n * @return {?}\n */\nfunction createRootData(\n  injector: Injector, rendererFactory: RendererFactory, rootSelectorOrNode: any): RootData {\n  const /** @type {?} */ renderer = rendererFactory.createRenderer(null, null);\n  let /** @type {?} */ element = rootSelectorOrNode;\n  if (typeof rootSelectorOrNode === 'string') {\n    element = renderer.selectRootElement(rootSelectorOrNode);\n  }\n  return {\n    injector,\n    selectorOrNode: rootSelectorOrNode,\n    element,\n    rendererFactory,\n    renderer\n  };\n}\n/**\n * @param {?} publicProviders\n * @param {?} componentProvider\n * @return {?}\n */\nfunction viewDef(publicProviders: Provider[], componentProvider: any): ViewDefinition {\n  var /** @type {?} */ viewDef: any = {};\n  // resolve public providers\n  const /** @type {?} */ publicProv: any = Object.create(null);\n  if (publicProviders) {\n    resolveReflectiveProviders(publicProviders).forEach(p => {\n      const /** @type {?} */ resolvedFactory = p.resolvedFactories[0];\n      publicProv[tokenKey(p.key)] = {\n        factory: resolvedFactory.factory,\n        dependencies: resolvedFactory.dependencies,\n        multi: p.multiProvider\n      };\n    });\n  }\n  viewDef.publicProviders = publicProv;\n\n  // combine to all providers\n  const /** @type {?} */ allProviders = Object.create(publicProv);\n  viewDef.allProviders = allProviders;\n\n  // resolve component provider\n  if (componentProvider) {\n    const /** @type {?} */ resolvedComp = resolveReflectiveProviders([componentProvider])[0];\n    const /** @type {?} */ resolvedCompFactory = resolvedComp.resolvedFactories[0];\n    viewDef.componentProvider = {\n      factory: resolvedCompFactory.factory,\n      dependencies: resolvedCompFactory.dependencies,\n      multi: false,\n    };\n    allProviders[tokenKey(resolvedComp.key)] = viewDef.componentProvider;\n  }\n\n  return viewDef;\n}\n/**\n * @param {?} publicProviders\n * @param {?} componentProvider\n * @return {?}\n */\nexport function createViewDefinitionFactory(publicProviders: Provider[], componentProvider: any) {\n  return () => {\n    return viewDef(publicProviders, componentProvider);\n  };\n}\n/**\n * @param {?} hostElement\n * @param {?} viewDef\n * @param {?} parentView\n * @param {?} root\n * @return {?}\n */\nfunction createRenderer(hostElement: any, viewDef: ViewDefinition,\n      parentView: ViewData, root: RootData) {\n    let /** @type {?} */ rendererType: RendererType = viewDef.componentRendererType;\n    let /** @type {?} */ view = parentView;\n    while (view && !rendererType) {\n      rendererType = view.def.componentRendererType;\n      view = view.parent;\n    }\n\n    if (!rendererType) {\n      return root.renderer;\n    } else {\n      return root.rendererFactory.createRenderer(hostElement, rendererType);\n    }\n}\n","import { stringify } from '../facade/lang';\nimport { Renderer } from '../render';\nimport { Injector } from '../di/injector';\nimport { resolveReflectiveProviders, ReflectiveDependency } from '../di/reflective_provider';\nimport { ReflectiveKey } from '../di/reflective_key';\nimport { Provider } from '../di/provider';\nimport { ElementRef } from './element_ref';\nimport { ViewContainerRef } from './view_container_ref';\nimport { createViewContainerData, createInjector } from './refs';\nimport {\n  ViewData, ProviderData, NodeDef, NodeFlags, DepDef, DepFlags,\n  asProviderData\n} from './types';\n\nconst /** @type {?} */ NOT_CREATED = new Object();\n\n// tslint:disable:variable-name\nconst /** @type {?} */ _tokenKeyCache = new Map<any, string>();\nconst /** @type {?} */ RendererTokenKey = tokenKey(Renderer);\nconst /** @type {?} */ ElementRefTokenKey = tokenKey(ElementRef);\nconst /** @type {?} */ ViewContainerRefTokenKey = tokenKey(ViewContainerRef);\n// const ChangeDetectorRefTokenKey = tokenKey(ChangeDetectorRef);\nconst /** @type {?} */ InjectorRefTokenKey = tokenKey(Injector);\n/**\n * @param {?} token\n * @return {?}\n */\nexport function tokenKey(token: any): string {\n  let /** @type {?} */ key = _tokenKeyCache.get(token);\n  if (!key) {\n    key = stringifyToken(token); // + '_' + _tokenKeyCache.size;\n    _tokenKeyCache.set(token, key);\n  }\n  return key;\n}\n/**\n * @param {?} token\n * @return {?}\n */\nfunction stringifyToken(token: any): string {\n  if (token instanceof ReflectiveDependency) {\n    return token.key.displayName;\n  }\n  if (token instanceof ReflectiveKey) {\n    return token.displayName;\n  }\n  return stringify(token);\n}\n/**\n * @param {?} view\n * @param {?} depDef\n * @param {?} allowPrivateServices\n * @param {?=} notFoundValue\n * @return {?}\n */\nexport function resolveDep(view: ViewData, depDef: DepDef, allowPrivateServices: boolean,\n  notFoundValue = Injector.THROW_IF_NOT_FOUND): any {\n\n  if (depDef.flags & DepFlags.Value) {\n    return depDef.token;\n  }\n  const /** @type {?} */ startView = view;\n  if (depDef.flags & DepFlags.Optional) {\n    notFoundValue = null;\n  }\n\n  const /** @type {?} */ tokenKey = depDef.tokenKey;\n\n  if (depDef.flags & DepFlags.SkipSelf) {\n    allowPrivateServices = false;\n    view = view.parent;\n  }\n\n  while (view) {\n    let /** @type {?} */ def = view.def;\n    if (def) {\n      switch (tokenKey) {\n        case RendererTokenKey:\n          return view.renderer;\n        case ElementRefTokenKey:\n          return new ElementRef(view.renderElement);\n        case ViewContainerRefTokenKey:\n          return view.viewContainer || view.viewContainerParent;\n        // case ChangeDetectorRefTokenKey: {\n        //   let cdView = findCompView(view, elDef, allowPrivateServices);\n        //   return createChangeDetectorRef(cdView);\n        // }\n        case InjectorRefTokenKey:\n          return createInjector(view);\n        default:\n          const /** @type {?} */ providerDef =\n            (allowPrivateServices ? def.allProviders : def.publicProviders)[tokenKey];\n          if (providerDef) {\n            const /** @type {?} */ providerData = asProviderData(view, providerDef.index);\n            if (providerData.instance === NOT_CREATED) {\n              providerData.instance = _createProviderInstance(view, providerDef);\n            }\n            return providerData.instance;\n          }\n      }\n    }\n    view = view.parent;\n  }\n  return startView.root.injector.get(depDef.token, notFoundValue);\n}\n/**\n * @param {?} view\n * @param {?} def\n * @return {?}\n */\nfunction _createProviderInstance(view: ViewData, def: NodeDef): any {\n  // private services can see other private services\n\n  const /** @type {?} */ allowPrivateServices = (def.flags & NodeFlags.PrivateProvider) > 0;\n  const /** @type {?} */ providerDef = def.provider;\n  let /** @type {?} */ deps: any[] = [];\n  if (providerDef.deps) {\n    deps = providerDef.deps.map(d => resolveDep(view, d, allowPrivateServices));\n  }\n  return providerDef.factory(...deps);\n}\n/**\n * @param {?} view\n * @param {?} def\n * @return {?}\n */\nexport function createProviderInstance(view: ViewData, def: NodeDef): any {\n  return def.flags & NodeFlags.LazyProvider ? NOT_CREATED : _createProviderInstance(view, def);\n}\n/**\n * @param {?} view\n * @param {?} index\n * @param {?} lifecycles\n * @return {?}\n */\nfunction callProviderLifecycles(view: ViewData, index: number, lifecycles: NodeFlags) {\n  const /** @type {?} */ provider = asProviderData(view, index).instance;\n  if (provider === NOT_CREATED) {\n    return;\n  }\n  if (lifecycles & NodeFlags.OnDestroy) {\n    provider.ngOnDestroy();\n  }\n}\n","import { ViewRef } from './view_ref';\nimport { ElementRef } from './element_ref';\nimport { Injector } from '../di/injector';\nimport { ComponentFactory } from '../component/factory';\nimport { ComponentRef } from '../component/reference';\n/**\n * @abstract\n */\nexport abstract class ViewContainerRef {\n/**\n * @abstract\n * @return {?}\n */\nanchorElement() {}\n/**\n * @abstract\n * @return {?}\n */\ninjector() {}\n/**\n * @abstract\n * @return {?}\n */\nparentInjector() {}\n/**\n * Destroys all Views in this container.\n * @abstract\n * @return {?}\n */\nclear() {}\n/**\n * Returns the ViewRef for the View located in this container at the specified index.\n * @abstract\n * @param {?} index\n * @return {?}\n */\nget(index: number) {}\n/**\n * Returns the number of Views currently attached to this container.\n * @abstract\n * @return {?}\n */\nlength() {}\n/**\n * Instantiates an Embedded View based on the TemplateRef `templateRef`} and inserts it\n * into this container at the specified `index`.\n * \n * If `index` is not specified, the new View will be inserted as the last View in the container.\n * \n * Returns the ViewRef for the newly created View.\n * @abstract\n * @template C\n * @param {?} templateRef\n * @param {?=} context\n * @param {?=} index\n * @return {?}\n */\ncreateEmbeddedView<C>(templateRef: any, context?: C, index?: number) {}\n/**\n * Instantiates a single Component and inserts its Host View into this container at the\n * specified `index`.\n * \n * The component is instantiated using its ComponentFactory which can be\n * obtained via ComponentFactoryResolver#resolveComponentFactory}.\n * \n * If `index` is not specified, the new View will be inserted as the last View in the container.\n * \n * You can optionally specify the Injector that will be used as parent for the Component.\n * \n * Returns the ComponentRef of the Host View created for the newly instantiated Component.\n * @abstract\n * @template C\n * @param {?} componentFactory\n * @param {?=} index\n * @param {?=} injector\n * @param {?=} projectableNodes\n * @return {?}\n */\ncreateComponent<C>(\n      componentFactory: ComponentFactory<C>, index?: number, injector?: Injector,\n      projectableNodes?: any[][]) {}\n/**\n * Returns the index of the View, specified via ViewRef, within the current container or\n * `-1` if this container doesn't contain the View.\n * @abstract\n * @param {?} viewRef\n * @return {?}\n */\nindexOf(viewRef: ViewRef) {}\n/**\n * Destroys a View attached to this container at the specified `index`.\n * \n * If `index` is not specified, the last View in the container will be removed.\n * @abstract\n * @param {?=} index\n * @return {?}\n */\nremove(index?: number) {}\n/**\n * Use along with #nsert} to move a View within the current container.\n * \n * If the `index` param is omitted, the last ViewRef is detached.\n * @abstract\n * @param {?=} index\n * @return {?}\n */\ndetach(index?: number) {}\n}\n","\nexport class ElementRef {\npublic nativeElement: any;\n/**\n * @param {?} nativeElement\n */\nconstructor(nativeElement: any) { this.nativeElement = nativeElement; }\n}\n\nfunction ElementRef_tsickle_Closure_declarations() {\n/** @type {?} */\nElementRef.prototype.nativeElement;\n}\n\n","export interface Visitor {\n  visitElement(element: Element, context: any): any;\n  visitAttribute(element: Element, attr: Attr, context: any): any;\n  visitText(text: Text, context: any): any;\n  visitComment(comment: Comment, context: any): any;\n}\n\nexport interface RendererType {\n  visitor: Visitor;\n  data: {[kind: string]: any};\n}\n/**\n * \\@experimental\n * @abstract\n */\nexport abstract class RendererFactory {\n/**\n * @abstract\n * @param {?} hostElement\n * @param {?} type\n * @return {?}\n */\ncreateRenderer(hostElement: any, type: RendererType) {}\n}\n/**\n * @abstract\n */\nexport abstract class Renderer {\n/**\n * @abstract\n * @param {?} context\n * @return {?}\n */\nparse(context: any) {}\n/**\n * @abstract\n * @return {?}\n */\ndestroy() {}\n/**\n * @abstract\n * @param {?} name\n * @param {?=} namespace\n * @return {?}\n */\ncreateElement(name: string, namespace?: string) {}\n/**\n * @abstract\n * @param {?} value\n * @return {?}\n */\ncreateComment(value: string) {}\n/**\n * @abstract\n * @param {?} value\n * @return {?}\n */\ncreateText(value: string) {}\n/**\n * @abstract\n * @param {?} node\n * @return {?}\n */\ndestroyNode(node: any) {}\n/**\n * @abstract\n * @param {?} parent\n * @param {?} newChild\n * @return {?}\n */\nappendChild(parent: any, newChild: any) {}\n/**\n * @abstract\n * @param {?} parent\n * @param {?} newChild\n * @param {?} refChild\n * @return {?}\n */\ninsertBefore(parent: any, newChild: any, refChild: any) {}\n/**\n * @abstract\n * @param {?} parent\n * @param {?} oldChild\n * @return {?}\n */\nremoveChild(parent: any, oldChild: any) {}\n/**\n * @abstract\n * @param {?} selectorOrNode\n * @return {?}\n */\nselectRootElement(selectorOrNode: string|any) {}\n/**\n * @abstract\n * @param {?} node\n * @return {?}\n */\nparentNode(node: any) {}\n/**\n * @abstract\n * @param {?} node\n * @return {?}\n */\nnextSibling(node: any) {}\n/**\n * @abstract\n * @param {?} el\n * @param {?} name\n * @param {?} value\n * @param {?=} namespace\n * @return {?}\n */\nsetAttribute(el: any, name: string, value: string, namespace?: string) {}\n/**\n * @abstract\n * @param {?} el\n * @param {?} name\n * @param {?=} namespace\n * @return {?}\n */\nremoveAttribute(el: any, name: string, namespace?: string) {}\n/**\n * @abstract\n * @param {?} el\n * @param {?} name\n * @return {?}\n */\naddClass(el: any, name: string) {}\n/**\n * @abstract\n * @param {?} el\n * @param {?} name\n * @return {?}\n */\nremoveClass(el: any, name: string) {}\n/**\n * @abstract\n * @param {?} el\n * @param {?} style\n * @param {?} value\n * @param {?} hasVendorPrefix\n * @param {?} hasImportant\n * @return {?}\n */\nsetStyle(\n      el: any, style: string, value: any, hasVendorPrefix: boolean, hasImportant: boolean) {}\n/**\n * @abstract\n * @param {?} el\n * @param {?} style\n * @param {?} hasVendorPrefix\n * @return {?}\n */\nremoveStyle(el: any, style: string, hasVendorPrefix: boolean) {}\n/**\n * @abstract\n * @param {?} el\n * @param {?} name\n * @param {?} value\n * @return {?}\n */\nsetProperty(el: any, name: string, value: any) {}\n/**\n * @abstract\n * @param {?} node\n * @param {?} value\n * @return {?}\n */\nsetValue(node: any, value: string) {}\n/**\n * @abstract\n * @param {?} target\n * @param {?} eventName\n * @param {?} callback\n * @return {?}\n */\nlisten(\n      target: 'window'|'document'|'body'|any, eventName: string,\n      callback: (event: any) => boolean | void) {}\n}\n","import { ClassType } from '../type';\nimport { Injector } from '../di/injector';\nimport { ElementRef } from '../view/element_ref';\nimport { ViewRef } from '../view/view_ref';\n/**\n * Represents an instance of a Component created via a ComponentFactory.\n * `ComponentRef` provides access to the Component Instance as well other objects related to this\n * Component Instance and allows you to destroy the Component Instance via the destroy method.\n * \n * @export\n * \\@class ComponentRef\n * @abstract\n */\nexport abstract class ComponentRef<C> {\n/**\n * Location of the component instance\n * @abstract\n * @return {?}\n */\nlocation() {}\n/**\n * The injector on which the component instance exists.\n * @abstract\n * @return {?}\n */\ninjector() {}\n/**\n * The instance of the Component.\n * @abstract\n * @return {?}\n */\ninstance() {}\n/**\n * @abstract\n * @return {?}\n */\nhostView() {}\n/**\n * The component type.\n * @abstract\n * @return {?}\n */\ncomponentType() {}\n/**\n * Destroys the component instance and all of the data structures associated with it.\n * @abstract\n * @return {?}\n */\ndestroy() {}\n/**\n * Allows to register a callback that will be called when the component is destroyed.\n * @abstract\n * @param {?} callback\n * @return {?}\n */\nonDestroy(callback: Function) {}\n}\n","import { ListWrapper } from '../facade/collection';\nimport { ComponentFactoryResolver } from '../component/factory_resolver';\nimport { ComponentRef } from '../component/reference';\nimport { ComponentFactory } from '../component/factory';\nimport { ClassType } from '../type';\nimport {\n  NotYetBootstrappedError,\n  AlreadyBootstrappedError\n} from './application_errors';\nimport { Component } from '../component/metadata';\nimport { ViewRef, InternalViewRef } from '../view/view_ref';\nimport { Injectable, Inject } from '../di/metadata';\nimport { Injector, THROW_IF_NOT_FOUND } from '../di/injector';\nimport {reflector} from '../reflection/reflection';\nimport { getPlatform } from './platform';\n/**\n * This is a reference of a Mojiito Application.\n * \n * @export\n * \\@class ApplicationRef\n */\nexport class ApplicationRef {\nprivate _rootComponents: ComponentRef<any>[] = [];\nprivate _rootComponentTypes: ClassType<any>[] = [];\nprivate _views: InternalViewRef[] = [];\n/**\n * @param {?} injector\n * @param {?} _componentFactoryResolver\n */\nconstructor(public injector: Injector,\nprivate _componentFactoryResolver: ComponentFactoryResolver) { }\n/**\n * @template C\n * @param {?} componentOrFactory\n * @return {?}\n */\nbootstrap<C>(componentOrFactory: ClassType<C> | ComponentFactory<C>): ComponentRef<C> {\n    let /** @type {?} */ componentFactory: ComponentFactory<C>;\n    if (componentOrFactory instanceof ComponentFactory) {\n      componentFactory = componentOrFactory;\n    } else {\n      componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentOrFactory);\n    }\n    this._rootComponentTypes.push(componentFactory.componentType);\n    const /** @type {?} */ compRef = componentFactory.create(this.injector, componentFactory.selector);\n    compRef.onDestroy(() => { this._unloadComponent(compRef); });\n    this._loadComponent(compRef);\n    return compRef;\n  }\n/**\n * @param {?} viewRef\n * @return {?}\n */\nattachView(viewRef: ViewRef): void {\n    const /** @type {?} */ view = ( /** @type {?} */((viewRef as InternalViewRef)));\n    this._views.push(view);\n    view.attachToAppRef(this);\n  }\n/**\n * @param {?} viewRef\n * @return {?}\n */\ndetachView(viewRef: ViewRef): void {\n    const /** @type {?} */ view = ( /** @type {?} */((viewRef as InternalViewRef)));\n    ListWrapper.remove(this._views, view);\n    view.detachFromAppRef();\n  }\n/**\n * @param {?} componentRef\n * @return {?}\n */\nprivate _loadComponent(componentRef: ComponentRef<any>): void {\n    this.attachView(componentRef.hostView);\n    // this.tick();\n    this._rootComponents.push(componentRef);\n  }\n/**\n * @param {?} componentRef\n * @return {?}\n */\nprivate _unloadComponent(componentRef: ComponentRef<any>): void {\n    this.detachView(componentRef.hostView);\n    ListWrapper.remove(this._rootComponents, componentRef);\n  }\n/**\n * @return {?}\n */\nonDestroy() {\n    this._views.slice().forEach((view) => view.destroy());\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Injector, },\n{type: ComponentFactoryResolver, },\n];\n}\n\nfunction ApplicationRef_tsickle_Closure_declarations() {\n/** @type {?} */\nApplicationRef.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nApplicationRef.ctorParameters;\n/** @type {?} */\nApplicationRef.prototype._rootComponents;\n/** @type {?} */\nApplicationRef.prototype._rootComponentTypes;\n/** @type {?} */\nApplicationRef.prototype._views;\n/** @type {?} */\nApplicationRef.prototype.injector;\n/** @type {?} */\nApplicationRef.prototype._componentFactoryResolver;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { ClassType } from '../type';\nimport { ComponentRef } from './reference';\nimport { Injector } from '../di/injector';\n/**\n * @abstract\n */\nexport abstract class ComponentFactory<C> {\n/**\n * @abstract\n * @return {?}\n */\nselector() {}\n/**\n * @abstract\n * @return {?}\n */\ncomponentType() {}\n/**\n * Creates a new component.\n * @abstract\n * @param {?} injector\n * @param {?=} rootSelectorOrNode\n * @return {?}\n */\ncreate(injector: Injector, rootSelectorOrNode?: string|any) {}\n}\n","import { ClassType } from '../type';\nimport { ComponentFactory } from './factory';\nimport { BaseError } from '../facade/error';\nimport { stringify } from '../facade/lang';\nexport class ComponentFactoryResolver {\nprivate _factories = new Map<any, ComponentFactory<any>>();\n/**\n * @param {?} factories\n * @param {?=} _parent\n */\nconstructor(factories: ComponentFactory<any>[],\nprivate _parent?: ComponentFactoryResolver) {\n    for (let i = 0; i < factories.length; i++) {\n      const factory = factories[i];\n      this._factories.set(factory.componentType, factory);\n    }\n  }\n/**\n * @template C\n * @param {?} componentType\n * @return {?}\n */\nresolveComponentFactory<C>(componentType: ClassType<C>): ComponentFactory<C> {\n    let /** @type {?} */ result = this._factories.get(componentType);\n    if (!result) {\n      if (!this._parent) {\n        throw new CouldNotResolveFactoryError(componentType);\n      }\n      result = this._parent.resolveComponentFactory(componentType);\n    }\n    return result;\n  }\n}\n\nfunction ComponentFactoryResolver_tsickle_Closure_declarations() {\n/** @type {?} */\nComponentFactoryResolver.prototype._factories;\n/** @type {?} */\nComponentFactoryResolver.prototype._parent;\n}\n\nexport class CouldNotResolveFactoryError extends BaseError {\n/**\n * @param {?} type\n */\nconstructor(type: ClassType<any>) {\n    super(`Could not resolve factory for \"${stringify(type)}! ` +\n      `Did you provide the component to the bootstrap function?`);\n  }\n}\n","import { PlatformAlreadyExistsError } from './platform_errors';\nimport { Injector } from '../di/injector';\nimport { InjectionToken } from '../di/injection_token';\nimport { Provider } from '../di/provider';\nimport { ReflectiveInjector } from '../di/reflective_injector';\nimport { ClassType } from '../type';\nimport { ComponentFactory } from '../component/factory';\n\nlet /** @type {?} */ _platform: PlatformRef;\n/**\n * @abstract\n */\nexport abstract class PlatformRef {\n/**\n * @abstract\n * @template C\n * @param {?} component\n * @return {?}\n */\nbootstrapComponent<C>(component: ClassType<C>) {}\n/**\n * @abstract\n * @return {?}\n */\ninjector() {}\n/**\n * @abstract\n * @param {?} callback\n * @return {?}\n */\nonDestroy(callback: () => void) {}\n/**\n * @abstract\n * @return {?}\n */\ndestroy() {}\n/**\n * @abstract\n * @return {?}\n */\ndestroyed() {}\n}\n/**\n * @return {?}\n */\nexport function getPlatform(): PlatformRef {\n  return _platform && !_platform.destroyed ? _platform : null;\n}\n/**\n * @param {?=} providers\n * @return {?}\n */\nexport function createPlatformFactory(providers: Provider[] = []):\n  (extraProviders?: Provider[]) => PlatformRef {\n  return (extraProviders: Provider[] = []) => {\n    if (getPlatform()) {\n      throw new PlatformAlreadyExistsError();\n    }\n\n    const /** @type {?} */ injector = ReflectiveInjector.resolveAndCreate(providers.concat(extraProviders));\n    _platform = injector.get(PlatformRef);\n    return _platform;\n  };\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// tslint:disable:variable-name class-name\n\n\nimport { Injector, THROW_IF_NOT_FOUND } from './injector';\nimport { Self, SkipSelf } from './metadata';\nimport { Provider } from './provider';\nimport {\n  AbstractProviderError, CyclicDependencyError,\n  InstantiationError, NoProviderError, OutOfBoundsError\n} from './reflective_errors';\nimport { ReflectiveKey } from './reflective_key';\nimport {\n  ReflectiveDependency, ResolvedReflectiveFactory,\n  ResolvedReflectiveProvider, resolveReflectiveProviders\n} from './reflective_provider';\n\n// Threshold for the dynamic version\nconst /** @type {?} */ UNDEFINED = new Object();\n/**\n * A ReflectiveDependency injection container used for instantiating objects and resolving\n * dependencies.\n * \n * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n * constructor dependencies.\n * \n * In typical use, application code asks for the dependencies in the constructor and they are\n * resolved by the `Injector`.\n * \n * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))\n * \n * The following example creates an `Injector` configured to create `Engine` and `Car`.\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * var car = injector.get(Car);\n * expect(car instanceof Car).toBe(true);\n * expect(car.engine instanceof Engine).toBe(true);\n * ```\n * \n * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\n * resolve all of the object's dependencies automatically.\n * \n * \\@stable\n * @abstract\n */\nexport abstract class ReflectiveInjector implements Injector {\n/**\n * Turns an array of provider definitions into an array of resolved providers.\n * \n * A resolution is a process of flattening multiple nested arrays and converting individual\n * providers into an array of {\\@link ResolvedReflectiveProvider}s.\n * \n * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\n * \n * expect(providers.length).toEqual(2);\n * \n * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\n * expect(providers[0].key.displayName).toBe(\"Car\");\n * expect(providers[0].dependencies.length).toEqual(1);\n * expect(providers[0].factory).toBeDefined();\n * \n * expect(providers[1].key.displayName).toBe(\"Engine\");\n * });\n * ```\n * \n * See {\\@link ReflectiveInjector#fromResolvedProviders} for more info.\n * @param {?} providers\n * @return {?}\n */\nstatic resolve(providers: Provider[]): ResolvedReflectiveProvider[] {\n    return resolveReflectiveProviders(providers);\n  }\n/**\n * Resolves an array of providers and creates an injector from those providers.\n * \n * The passed-in providers can be an array of `Type`, {\\@link Provider},\n * or a recursive array of more providers.\n * \n * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * expect(injector.get(Car) instanceof Car).toBe(true);\n * ```\n * \n * This function is slower than the corresponding `fromResolvedProviders`\n * because it needs to resolve the passed-in providers first.\n * See {\\@link Injector#resolve} and {\\@link Injector#fromResolvedProviders}.\n * @param {?} providers\n * @param {?=} parent\n * @return {?}\n */\nstatic resolveAndCreate(providers: Provider[], parent: Injector = null): ReflectiveInjector {\n    const /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);\n  }\n/**\n * Creates an injector from previously resolved providers.\n * \n * This API is the recommended way to construct injectors in performance-sensitive parts.\n * \n * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var providers = ReflectiveInjector.resolve([Car, Engine]);\n * var injector = ReflectiveInjector.fromResolvedProviders(providers);\n * expect(injector.get(Car) instanceof Car).toBe(true);\n * ```\n * \\@experimental\n * @param {?} providers\n * @param {?=} parent\n * @return {?}\n */\nstatic fromResolvedProviders(providers: ResolvedReflectiveProvider[], parent: Injector = null):\n    ReflectiveInjector {\n    return new ReflectiveInjector_(providers, parent);\n  }\n/**\n * Parent of this injector.\n * \n * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n * -->\n * \n * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))\n * \n * ```typescript\n * var parent = ReflectiveInjector.resolveAndCreate([]);\n * var child = parent.resolveAndCreateChild([]);\n * expect(child.parent).toBe(parent);\n * ```\n * @abstract\n * @return {?}\n */\nparent() {}\n/**\n * Resolves an array of providers and creates a child injector from those providers.\n * \n * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n * -->\n * \n * The passed-in providers can be an array of `Type`, {\\@link Provider},\n * or a recursive array of more providers.\n * \n * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))\n * \n * ```typescript\n * class ParentProvider {}\n * class ChildProvider {}\n * \n * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);\n * var child = parent.resolveAndCreateChild([ChildProvider]);\n * \n * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n * ```\n * \n * This function is slower than the corresponding `createChildFromResolved`\n * because it needs to resolve the passed-in providers first.\n * See {\\@link Injector#resolve} and {\\@link Injector#createChildFromResolved}.\n * @abstract\n * @param {?} providers\n * @return {?}\n */\nresolveAndCreateChild(providers: Provider[]) {}\n/**\n * Creates a child injector from previously resolved providers.\n * \n * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n * -->\n * \n * This API is the recommended way to construct injectors in performance-sensitive parts.\n * \n * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))\n * \n * ```typescript\n * class ParentProvider {}\n * class ChildProvider {}\n * \n * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);\n * var childProviders = ReflectiveInjector.resolve([ChildProvider]);\n * \n * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);\n * var child = parent.createChildFromResolved(childProviders);\n * \n * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n * ```\n * @abstract\n * @param {?} providers\n * @return {?}\n */\ncreateChildFromResolved(providers: ResolvedReflectiveProvider[]) {}\n/**\n * Resolves a provider and instantiates an object in the context of the injector.\n * \n * The created object does not get cached by the injector.\n * \n * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n * \n * var car = injector.resolveAndInstantiate(Car);\n * expect(car.engine).toBe(injector.get(Engine));\n * expect(car).not.toBe(injector.resolveAndInstantiate(Car));\n * ```\n * @abstract\n * @param {?} provider\n * @return {?}\n */\nresolveAndInstantiate(provider: Provider) {}\n/**\n * Instantiates an object using a resolved provider in the context of the injector.\n * \n * The created object does not get cached by the injector.\n * \n * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n * var carProvider = ReflectiveInjector.resolve([Car])[0];\n * var car = injector.instantiateResolved(carProvider);\n * expect(car.engine).toBe(injector.get(Engine));\n * expect(car).not.toBe(injector.instantiateResolved(carProvider));\n * ```\n * @abstract\n * @param {?} provider\n * @return {?}\n */\ninstantiateResolved(provider: ResolvedReflectiveProvider) {}\n/**\n * @abstract\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget(token: any, notFoundValue?: any) {}\n}\nexport class ReflectiveInjector_ implements ReflectiveInjector {\n/**\n * \\@internal\n */\n_constructionCounter = 0;\n/**\n * \\@internal\n */\npublic _providers: ResolvedReflectiveProvider[];\n/**\n * \\@internal\n */\npublic _parent: Injector;\n\n  keyIds: number[];\n  objs: any[];\n/**\n * Private\n * @param {?} _providers\n * @param {?=} _parent\n */\nconstructor(_providers: ResolvedReflectiveProvider[], _parent: Injector = null) {\n    this._providers = _providers;\n    this._parent = _parent;\n\n    const len = _providers.length;\n\n    this.keyIds = new Array(len);\n    this.objs = new Array(len);\n\n    for (let i = 0; i < len; i++) {\n      this.keyIds[i] = _providers[i].key.id;\n      this.objs[i] = UNDEFINED;\n    }\n  }\n/**\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget(token: any, notFoundValue: any = THROW_IF_NOT_FOUND): any {\n    return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);\n  }\n/**\n * @return {?}\n */\nget parent(): Injector { return this._parent; }\n/**\n * @param {?} providers\n * @return {?}\n */\nresolveAndCreateChild(providers: Provider[]): ReflectiveInjector {\n    const /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return this.createChildFromResolved(ResolvedReflectiveProviders);\n  }\n/**\n * @param {?} providers\n * @return {?}\n */\ncreateChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector {\n    const /** @type {?} */ inj = new ReflectiveInjector_(providers);\n    inj._parent = this;\n    return inj;\n  }\n/**\n * @param {?} provider\n * @return {?}\n */\nresolveAndInstantiate(provider: Provider): any {\n    return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);\n  }\n/**\n * @param {?} provider\n * @return {?}\n */\ninstantiateResolved(provider: ResolvedReflectiveProvider): any {\n    return this._instantiateProvider(provider);\n  }\n/**\n * @param {?} index\n * @return {?}\n */\ngetProviderAtIndex(index: number): ResolvedReflectiveProvider {\n    if (index < 0 || index >= this._providers.length) {\n      throw new OutOfBoundsError(index);\n    }\n    return this._providers[index];\n  }\n/**\n * \\@internal\n * @param {?} provider\n * @return {?}\n */\n_new(provider: ResolvedReflectiveProvider): any {\n    if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {\n      throw new CyclicDependencyError(this, provider.key);\n    }\n    return this._instantiateProvider(provider);\n  }\n/**\n * @return {?}\n */\nprivate _getMaxNumberOfObjects(): number { return this.objs.length; }\n/**\n * @param {?} provider\n * @return {?}\n */\nprivate _instantiateProvider(provider: ResolvedReflectiveProvider): any {\n    if (provider.multiProvider) {\n      const /** @type {?} */ res = new Array(provider.resolvedFactories.length);\n      for (let /** @type {?} */ i = 0; i < provider.resolvedFactories.length; ++i) {\n        res[i] = this._instantiate(provider, provider.resolvedFactories[i]);\n      }\n      return res;\n    } else {\n      return this._instantiate(provider, provider.resolvedFactories[0]);\n    }\n  }\n/**\n * @param {?} provider\n * @param {?} ResolvedReflectiveFactory\n * @return {?}\n */\nprivate _instantiate(\n    provider: ResolvedReflectiveProvider,\n    ResolvedReflectiveFactory: ResolvedReflectiveFactory): any {\n    const /** @type {?} */ factory = ResolvedReflectiveFactory.factory;\n\n    let /** @type {?} */ deps: any[];\n    try {\n      deps =\n        ResolvedReflectiveFactory.dependencies.map(dep => this._getByReflectiveDependency(dep));\n    } catch ( /** @type {?} */e) {\n      if (e instanceof AbstractProviderError || e instanceof InstantiationError) {\n        e.addKey(this, provider.key);\n      }\n      throw e;\n    }\n\n    let /** @type {?} */ obj: any;\n    try {\n      obj = factory(...deps);\n    } catch ( /** @type {?} */e) {\n      throw new InstantiationError(this, e, e.stack, provider.key);\n    }\n\n    return obj;\n  }\n/**\n * @param {?} dep\n * @return {?}\n */\nprivate _getByReflectiveDependency(dep: ReflectiveDependency): any {\n    return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);\n  }\n/**\n * @param {?} key\n * @param {?} visibility\n * @param {?} notFoundValue\n * @return {?}\n */\nprivate _getByKey(key: ReflectiveKey, visibility: Self | SkipSelf, notFoundValue: any): any {\n    if (key === INJECTOR_KEY) {\n      return this;\n    }\n\n    if (visibility instanceof Self) {\n      return this._getByKeySelf(key, notFoundValue);\n\n    } else {\n      return this._getByKeyDefault(key, notFoundValue, visibility);\n    }\n  }\n/**\n * @param {?} keyId\n * @return {?}\n */\nprivate _getObjByKeyId(keyId: number): any {\n    for (let /** @type {?} */ i = 0; i < this.keyIds.length; i++) {\n      if (this.keyIds[i] === keyId) {\n        if (this.objs[i] === UNDEFINED) {\n          this.objs[i] = this._new(this._providers[i]);\n        }\n\n        return this.objs[i];\n      }\n    }\n\n    return UNDEFINED;\n  }\n/**\n * \\@internal\n * @param {?} key\n * @param {?} notFoundValue\n * @return {?}\n */\n_throwOrNull(key: ReflectiveKey, notFoundValue: any): any {\n    if (notFoundValue !== THROW_IF_NOT_FOUND) {\n      return notFoundValue;\n    } else {\n      throw new NoProviderError(this, key);\n    }\n  }\n/**\n * \\@internal\n * @param {?} key\n * @param {?} notFoundValue\n * @return {?}\n */\n_getByKeySelf(key: ReflectiveKey, notFoundValue: any): any {\n    const /** @type {?} */ obj = this._getObjByKeyId(key.id);\n    return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);\n  }\n/**\n * \\@internal\n * @param {?} key\n * @param {?} notFoundValue\n * @param {?} visibility\n * @return {?}\n */\n_getByKeyDefault(key: ReflectiveKey, notFoundValue: any, visibility: Self | SkipSelf): any {\n    let /** @type {?} */ inj: Injector;\n\n    if (visibility instanceof SkipSelf) {\n      inj = this._parent;\n    } else {\n      inj = this;\n    }\n\n    while (inj instanceof ReflectiveInjector_) {\n      const /** @type {?} */ inj_ = /** @type {?} */(( <ReflectiveInjector_>inj));\n      const /** @type {?} */ obj = inj_._getObjByKeyId(key.id);\n      if (obj !== UNDEFINED) return obj;\n      inj = inj_._parent;\n    }\n    if (inj !== null) {\n      return inj.get(key.token, notFoundValue);\n    } else {\n      return this._throwOrNull(key, notFoundValue);\n    }\n  }\n/**\n * @return {?}\n */\nget displayName(): string {\n    const /** @type {?} */ providers =\n      _mapProviders(this, (b: ResolvedReflectiveProvider) => ' \"' + b.key.displayName + '\" ')\n        .join(', ');\n    return `ReflectiveInjector(providers: [${providers}])`;\n  }\n/**\n * @return {?}\n */\ntoString(): string { return this.displayName; }\n}\n\nfunction ReflectiveInjector__tsickle_Closure_declarations() {\n/**\n * \\@internal\n * @type {?}\n */\nReflectiveInjector_.prototype._constructionCounter;\n/**\n * \\@internal\n * @type {?}\n */\nReflectiveInjector_.prototype._providers;\n/**\n * \\@internal\n * @type {?}\n */\nReflectiveInjector_.prototype._parent;\n/** @type {?} */\nReflectiveInjector_.prototype.keyIds;\n/** @type {?} */\nReflectiveInjector_.prototype.objs;\n}\n\n\nconst /** @type {?} */ INJECTOR_KEY = ReflectiveKey.get(Injector);\n/**\n * @param {?} injector\n * @param {?} fn\n * @return {?}\n */\nfunction _mapProviders(injector: ReflectiveInjector_, fn: Function): any[] {\n  const /** @type {?} */ res: any[] = new Array(injector._providers.length);\n  for (let /** @type {?} */ i = 0; i < injector._providers.length; ++i) {\n    res[i] = fn(injector.getProviderAtIndex(i));\n  }\n  return res;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {reflector} from '../reflection/reflection';\nimport { ClassType } from '../type';\nimport { resolveForwardRef } from './forward_ref';\nimport { Inject, Optional, SkipSelf, Self } from './metadata';\nimport {\n  ClassProvider, ExistingProvider, FactoryProvider,\n  Provider, TypeProvider, ValueProvider\n} from './provider';\nimport {\n  InvalidProviderError, MixingMultiProvidersWithRegularProvidersError,\n  NoAnnotationError\n} from './reflective_errors';\nimport { ReflectiveKey } from './reflective_key';\n\ninterface NormalizedProvider extends TypeProvider, ValueProvider, ClassProvider, ExistingProvider,\n  FactoryProvider { }\n/**\n * `Dependency` is used by the framework to extend DI.\n * This is internal and should not be used directly.\n */\nexport class ReflectiveDependency {\n/**\n * @param {?} key\n * @param {?} optional\n * @param {?} visibility\n */\nconstructor(\npublic key: ReflectiveKey,\npublic optional: boolean,\npublic visibility: Self|SkipSelf) {}\n/**\n * @param {?} key\n * @return {?}\n */\nstatic fromKey(key: ReflectiveKey): ReflectiveDependency {\n    return new ReflectiveDependency(key, false, null);\n  }\n}\n\nfunction ReflectiveDependency_tsickle_Closure_declarations() {\n/** @type {?} */\nReflectiveDependency.prototype.key;\n/** @type {?} */\nReflectiveDependency.prototype.optional;\n/** @type {?} */\nReflectiveDependency.prototype.visibility;\n}\n\n\nconst /** @type {?} */ _EMPTY_LIST: any[] = [];\n\n/**\n * An internal resolved representation of a {@link Provider} used by the {@link Injector}.\n *\n * It is usually created automatically by `Injector.resolveAndCreate`.\n *\n * It can be created manually, as follows:\n *\n * ### Example ([live demo](http://plnkr.co/edit/RfEnhh8kUEI0G3qsnIeT?p%3Dpreview&p=preview))\n *\n * ```typescript\n * var resolvedProviders = Injector.resolve([{ provide: 'message', useValue: 'Hello' }]);\n * var injector = Injector.fromResolvedProviders(resolvedProviders);\n *\n * expect(injector.get('message')).toEqual('Hello');\n * ```\n *\n * @experimental\n */\nexport interface ResolvedReflectiveProvider {\n  /**\n   * A key, usually a `Type<any>`.\n   */\n  key: ReflectiveKey;\n\n  /**\n   * Factory function which can return an instance of an object represented by a key.\n   */\n  resolvedFactories: ResolvedReflectiveFactory[];\n\n  /**\n   * Indicates if the provider is a multi-provider or a regular provider.\n   */\n  multiProvider: boolean;\n}\nexport class ResolvedReflectiveProvider_ implements ResolvedReflectiveProvider {\n/**\n * @param {?} key\n * @param {?} resolvedFactories\n * @param {?} multiProvider\n */\nconstructor(\npublic key: ReflectiveKey,\npublic resolvedFactories: ResolvedReflectiveFactory[],\npublic multiProvider: boolean) { }\n/**\n * @return {?}\n */\nget resolvedFactory(): ResolvedReflectiveFactory { return this.resolvedFactories[0]; }\n}\n\nfunction ResolvedReflectiveProvider__tsickle_Closure_declarations() {\n/** @type {?} */\nResolvedReflectiveProvider_.prototype.key;\n/** @type {?} */\nResolvedReflectiveProvider_.prototype.resolvedFactories;\n/** @type {?} */\nResolvedReflectiveProvider_.prototype.multiProvider;\n}\n\n/**\n * An internal resolved representation of a factory function created by resolving {\\@link\n * Provider}.\n * \\@experimental\n */\nexport class ResolvedReflectiveFactory {\n/**\n * @param {?} factory\n * @param {?} dependencies\n */\nconstructor(\npublic factory: Function,\npublic dependencies: ReflectiveDependency[]) { }\n}\n\nfunction ResolvedReflectiveFactory_tsickle_Closure_declarations() {\n/**\n * Factory function which can return an instance of an object represented by a key.\n * @type {?}\n */\nResolvedReflectiveFactory.prototype.factory;\n/**\n * Arguments (dependencies) to the `factory` function.\n * @type {?}\n */\nResolvedReflectiveFactory.prototype.dependencies;\n}\n\n/**\n * Resolve a single provider.\n * @param {?} provider\n * @return {?}\n */\nfunction resolveReflectiveFactory(provider: NormalizedProvider): ResolvedReflectiveFactory {\n  let /** @type {?} */ factoryFn: Function;\n  let /** @type {?} */ resolvedDeps: ReflectiveDependency[];\n  if (provider.useClass) {\n    const /** @type {?} */ useClass = resolveForwardRef(provider.useClass);\n    factoryFn = reflector.factory(useClass);\n    resolvedDeps = _dependenciesFor(useClass);\n  } else if (provider.useExisting) {\n    factoryFn = (aliasInstance: any) => aliasInstance;\n    resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];\n  } else if (provider.useFactory) {\n    factoryFn = provider.useFactory;\n    resolvedDeps = constructDependencies(provider.useFactory, provider.deps);\n  } else {\n    factoryFn = () => provider.useValue;\n    resolvedDeps = _EMPTY_LIST;\n  }\n  return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);\n}\n/**\n * Converts the {\\@link Provider} into {\\@link ResolvedProvider}.\n * \n * {\\@link Injector} internally only uses {\\@link ResolvedProvider}, {\\@link Provider} contains\n * convenience provider syntax.\n * @param {?} provider\n * @return {?}\n */\nfunction resolveReflectiveProvider(provider: NormalizedProvider): ResolvedReflectiveProvider {\n  return new ResolvedReflectiveProvider_(\n    ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi);\n}\n/**\n * Resolve a list of Providers.\n * @param {?} providers\n * @return {?}\n */\nexport function resolveReflectiveProviders(providers: Provider[]): ResolvedReflectiveProvider[] {\n  const /** @type {?} */ normalized = _normalizeProviders(providers, []);\n  const /** @type {?} */ resolved = normalized.map(resolveReflectiveProvider);\n  const /** @type {?} */ resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());\n  return Array.from(resolvedProviderMap.values());\n}\n/**\n * Merges a list of ResolvedProviders into a list where\n * each key is contained exactly once and multi providers\n * have been merged.\n * @param {?} providers\n * @param {?} normalizedProvidersMap\n * @return {?}\n */\nexport function mergeResolvedReflectiveProviders(\n  providers: ResolvedReflectiveProvider[],\n  normalizedProvidersMap: Map<number, ResolvedReflectiveProvider>):\n  Map<number, ResolvedReflectiveProvider> {\n  for (let /** @type {?} */ i = 0; i < providers.length; i++) {\n    const /** @type {?} */ provider = providers[i];\n    const /** @type {?} */ existing = normalizedProvidersMap.get(provider.key.id);\n    if (existing) {\n      if (provider.multiProvider !== existing.multiProvider) {\n        throw new MixingMultiProvidersWithRegularProvidersError(existing, provider);\n      }\n      if (provider.multiProvider) {\n        for (let /** @type {?} */ j = 0; j < provider.resolvedFactories.length; j++) {\n          existing.resolvedFactories.push(provider.resolvedFactories[j]);\n        }\n      } else {\n        normalizedProvidersMap.set(provider.key.id, provider);\n      }\n    } else {\n      let /** @type {?} */ resolvedProvider: ResolvedReflectiveProvider;\n      if (provider.multiProvider) {\n        resolvedProvider = new ResolvedReflectiveProvider_(\n          provider.key, provider.resolvedFactories.slice(), provider.multiProvider);\n      } else {\n        resolvedProvider = provider;\n      }\n      normalizedProvidersMap.set(provider.key.id, resolvedProvider);\n    }\n  }\n  return normalizedProvidersMap;\n}\n/**\n * @param {?} providers\n * @param {?} res\n * @return {?}\n */\nfunction _normalizeProviders(providers: Provider[], res: Provider[]): Provider[] {\n  providers.forEach(b => {\n    if (b instanceof Function) {\n      res.push({ provide: b, useClass: b });\n\n    } else if (b && typeof b == 'object' && ( /** @type {?} */((b as any))).provide !== undefined) {\n      res.push( /** @type {?} */((b as NormalizedProvider)));\n\n    } else if (b instanceof Array) {\n      _normalizeProviders(b, res);\n\n    } else {\n      throw new InvalidProviderError(b);\n    }\n  });\n\n  return res;\n}\n/**\n * @param {?} typeOrFunc\n * @param {?} dependencies\n * @return {?}\n */\nexport function constructDependencies(\n  typeOrFunc: any, dependencies: any[]): ReflectiveDependency[] {\n  if (!dependencies) {\n    return _dependenciesFor(typeOrFunc);\n  } else {\n    const /** @type {?} */ params: any[][] = dependencies.map(t => [t]);\n    return dependencies.map(t => _extractToken(typeOrFunc, t, params));\n  }\n}\n/**\n * @param {?} typeOrFunc\n * @return {?}\n */\nfunction _dependenciesFor(typeOrFunc: any): ReflectiveDependency[] {\n  const /** @type {?} */ params = reflector.parameters(typeOrFunc);\n\n  if (!params) return [];\n  if (params.some(p => p == null)) {\n    throw new NoAnnotationError(typeOrFunc, params);\n  }\n  return params.map(p => _extractToken(typeOrFunc, p, params));\n}\n/**\n * @param {?} typeOrFunc\n * @param {?} metadata\n * @param {?} params\n * @return {?}\n */\nfunction _extractToken(\n  typeOrFunc: any, metadata: any[] | any, params: any[][]): ReflectiveDependency {\n  let /** @type {?} */ token: any = null;\n  let /** @type {?} */ optional = false;\n\n  if (!Array.isArray(metadata)) {\n    if (metadata instanceof Inject) {\n      return _createDependency(metadata.token, optional, null);\n    } else {\n      return _createDependency(metadata, optional, null);\n    }\n  }\n\n  let /** @type {?} */ visibility: Self | SkipSelf = null;\n\n  for (let /** @type {?} */ i = 0; i < metadata.length; ++i) {\n    const /** @type {?} */ paramMetadata = metadata[i];\n\n    if (paramMetadata instanceof Function) {\n      token = paramMetadata;\n\n    } else if (paramMetadata instanceof Inject) {\n      token = paramMetadata.token;\n\n    } else if (paramMetadata instanceof Optional) {\n      optional = true;\n\n    } else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {\n      visibility = paramMetadata;\n    }\n  }\n\n  token = resolveForwardRef(token);\n\n  if (token != null) {\n    return _createDependency(token, optional, visibility);\n  } else {\n    throw new NoAnnotationError(typeOrFunc, params);\n  }\n}\n/**\n * @param {?} token\n * @param {?} optional\n * @param {?} visibility\n * @return {?}\n */\nfunction _createDependency(\n  token: any, optional: boolean, visibility: Self | SkipSelf): ReflectiveDependency {\n  return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {stringify} from '../facade/lang';\nimport {resolveForwardRef} from './forward_ref';\n/**\n * A unique object used for retrieving items from the {\\@link ReflectiveInjector}.\n * \n * Keys have:\n * - a system-wide unique `id`.\n * - a `token`.\n * \n * `Key` is used internally by {\\@link ReflectiveInjector} because its system-wide unique `id` allows\n * the\n * injector to store created objects in a more efficient way.\n * \n * `Key` should not be created directly. {\\@link ReflectiveInjector} creates keys automatically when\n * resolving\n * providers.\n * \\@experimental\n */\nexport class ReflectiveKey {\n/**\n * Private\n * @param {?} token\n * @param {?} id\n */\nconstructor(public token: Object,\npublic id: number) {\n    if (!token) {\n      throw new Error('Token must be defined!');\n    }\n  }\n/**\n * Returns a stringified token.\n * @return {?}\n */\nget displayName(): string { return stringify(this.token); }\n/**\n * Retrieves a `Key` for a token.\n * @param {?} token\n * @return {?}\n */\nstatic get(token: Object): ReflectiveKey {\n    return _globalKeyRegistry.get(resolveForwardRef(token));\n  }\n/**\n * @return {?} the number of keys registered in the system.\n */\nstatic get numberOfKeys(): number { return _globalKeyRegistry.numberOfKeys; }\n}\n\nfunction ReflectiveKey_tsickle_Closure_declarations() {\n/** @type {?} */\nReflectiveKey.prototype.token;\n/** @type {?} */\nReflectiveKey.prototype.id;\n}\n\n/**\n * \\@internal\n */\nexport class KeyRegistry {\nprivate _allKeys = new Map<Object, ReflectiveKey>();\n/**\n * @param {?} token\n * @return {?}\n */\nget(token: Object): ReflectiveKey {\n    if (token instanceof ReflectiveKey) return token;\n\n    if (this._allKeys.has(token)) {\n      return this._allKeys.get(token);\n    }\n\n    const /** @type {?} */ newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);\n    this._allKeys.set(token, newKey);\n    return newKey;\n  }\n/**\n * @return {?}\n */\nget numberOfKeys(): number { return this._allKeys.size; }\n}\n\nfunction KeyRegistry_tsickle_Closure_declarations() {\n/** @type {?} */\nKeyRegistry.prototype._allKeys;\n}\n\n\nconst /** @type {?} */ _globalKeyRegistry = new KeyRegistry();\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport { stringify } from '../facade/lang';\nimport { ClassType } from '../type';\n\n\n/**\n * An interface that a function passed into {@link forwardRef} has to implement.\n *\n * ### Example\n *\n * {@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref_fn'}\n * @experimental\n */\nexport interface ForwardRefFn { (): any; }\n/**\n * Allows to refer to references which are not yet defined.\n * \n * For instance, `forwardRef` is used when the `token` which we need to refer to for the purposes of\n * DI is declared,\n * but not yet defined. It is also used when the `token` which we use when creating a query is not\n * yet defined.\n * \n * ### Example\n * {\\@example core/di/ts/forward_ref/forward_ref_spec.ts region='forward_ref'}\n * \\@experimental\n * @param {?} forwardRefFn\n * @return {?}\n */\nexport function forwardRef(forwardRefFn: ForwardRefFn): ClassType<any> {\n  ( /** @type {?} */((<any>forwardRefFn))).__forward_ref__ = forwardRef;\n  ( /** @type {?} */((<any>forwardRefFn))).toString = function () { return stringify(this()); };\n  return ( /** @type {?} */((<ClassType<any>> /** @type {?} */((<any>forwardRefFn)))));\n}\n/**\n * Lazily retrieves the reference value from a forwardRef.\n * \n * Acts as the identity function when given a non-forward-ref value.\n * \n * ### Example ([live demo](http://plnkr.co/edit/GU72mJrk1fiodChcmiDR?p=preview))\n * \n * {\\@example core/di/ts/forward_ref/forward_ref_spec.ts region='resolve_forward_ref'}\n * \n * See: {\\@link forwardRef}\n * \\@experimental\n * @param {?} type\n * @return {?}\n */\nexport function resolveForwardRef(type: any): any {\n  if (typeof type === 'function' && type.hasOwnProperty('__forward_ref__') &&\n    type.__forward_ref__ === forwardRef) {\n    return ( /** @type {?} */((<ForwardRefFn>type)))();\n  } else {\n    return type;\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport { BaseError, WrappedError } from '../facade/error';\nimport { stringify } from '../facade/lang';\nimport { ClassType } from '../type';\n\nimport { ReflectiveInjector } from './reflective_injector';\nimport { ReflectiveKey } from './reflective_key';\n/**\n * @param {?} keys\n * @return {?}\n */\nfunction findFirstClosedCycle(keys: any[]): any[] {\n  const /** @type {?} */ res: any[] = [];\n  for (let /** @type {?} */ i = 0; i < keys.length; ++i) {\n    if (res.indexOf(keys[i]) > -1) {\n      res.push(keys[i]);\n      return res;\n    }\n    res.push(keys[i]);\n  }\n  return res;\n}\n/**\n * @param {?} keys\n * @return {?}\n */\nfunction constructResolvingPath(keys: any[]): string {\n  if (keys.length > 1) {\n    const /** @type {?} */ reversed = findFirstClosedCycle(keys.slice().reverse());\n    const /** @type {?} */ tokenStrs = reversed.map(k => stringify(k.token));\n    return ' (' + tokenStrs.join(' -> ') + ')';\n  }\n\n  return '';\n}\n/**\n * Base class for all errors arising from misconfigured providers.\n * \\@stable\n */\nexport class AbstractProviderError extends BaseError {\n/**\n * \\@internal\n */\nmessage: string;\n/**\n * \\@internal\n */\nkeys: ReflectiveKey[];\n/**\n * \\@internal\n */\ninjectors: ReflectiveInjector[];\n/**\n * \\@internal\n */\nconstructResolvingMessage: Function;\n/**\n * @param {?} injector\n * @param {?} key\n * @param {?} constructResolvingMessage\n */\nconstructor(\n    injector: ReflectiveInjector, key: ReflectiveKey, constructResolvingMessage: Function) {\n    super('DI Error');\n    this.keys = [key];\n    this.injectors = [injector];\n    this.constructResolvingMessage = constructResolvingMessage;\n    this.message = this.constructResolvingMessage(this.keys);\n  }\n/**\n * @param {?} injector\n * @param {?} key\n * @return {?}\n */\naddKey(injector: ReflectiveInjector, key: ReflectiveKey): void {\n    this.injectors.push(injector);\n    this.keys.push(key);\n    this.message = this.constructResolvingMessage(this.keys);\n  }\n}\n\nfunction AbstractProviderError_tsickle_Closure_declarations() {\n/**\n * \\@internal\n * @type {?}\n */\nAbstractProviderError.prototype.message;\n/**\n * \\@internal\n * @type {?}\n */\nAbstractProviderError.prototype.keys;\n/**\n * \\@internal\n * @type {?}\n */\nAbstractProviderError.prototype.injectors;\n/**\n * \\@internal\n * @type {?}\n */\nAbstractProviderError.prototype.constructResolvingMessage;\n}\n\n/**\n * Thrown when trying to retrieve a dependency by key from {\\@link Injector}, but the\n * {\\@link Injector} does not have a {\\@link Provider} for the given key.\n * \n * ### Example ([live demo](http://plnkr.co/edit/vq8D3FRB9aGbnWJqtEPE?p=preview))\n * \n * ```typescript\n * class A {\n *   constructor(b:B) {}\n * }\n * \n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n * \\@stable\n */\nexport class NoProviderError extends AbstractProviderError {\n/**\n * @param {?} injector\n * @param {?} key\n */\nconstructor(injector: ReflectiveInjector, key: ReflectiveKey) {\n    super(injector, key, function (keys: any[]) {\n      const first = stringify(keys[0].token);\n      return `No provider for ${first}!${constructResolvingPath(keys)}`;\n    });\n  }\n}\n/**\n * Thrown when dependencies form a cycle.\n * \n * ### Example ([live demo](http://plnkr.co/edit/wYQdNos0Tzql3ei1EV9j?p=info))\n * \n * ```typescript\n * var injector = Injector.resolveAndCreate([\n *   {provide: \"one\", useFactory: (two) => \"two\", deps: [[new Inject(\"two\")]]},\n *   {provide: \"two\", useFactory: (one) => \"one\", deps: [[new Inject(\"one\")]]}\n * ]);\n * \n * expect(() => injector.get(\"one\")).toThrowError();\n * ```\n * \n * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.\n * \\@stable\n */\nexport class CyclicDependencyError extends AbstractProviderError {\n/**\n * @param {?} injector\n * @param {?} key\n */\nconstructor(injector: ReflectiveInjector, key: ReflectiveKey) {\n    super(injector, key, function (keys: any[]) {\n      return `Cannot instantiate cyclic dependency!${constructResolvingPath(keys)}`;\n    });\n  }\n}\n/**\n * Thrown when a constructing type returns with an Error.\n * \n * The `InstantiationError` class contains the original error plus the dependency graph which caused\n * this object to be instantiated.\n * \n * ### Example ([live demo](http://plnkr.co/edit/7aWYdcqTQsP0eNqEdUAf?p=preview))\n * \n * ```typescript\n * class A {\n *   constructor() {\n *     throw new Error('message');\n *   }\n * }\n * \n * var injector = Injector.resolveAndCreate([A]);\n * try {\n *   injector.get(A);\n * } catch (e) {\n *   expect(e instanceof InstantiationError).toBe(true);\n *   expect(e.originalException.message).toEqual(\"message\");\n *   expect(e.originalStack).toBeDefined();\n * }\n * ```\n * \\@stable\n */\nexport class InstantiationError extends WrappedError {\n/**\n * \\@internal\n */\nkeys: ReflectiveKey[];\n/**\n * \\@internal\n */\ninjectors: ReflectiveInjector[];\n/**\n * @param {?} injector\n * @param {?} originalException\n * @param {?} originalStack\n * @param {?} key\n */\nconstructor(\n    injector: ReflectiveInjector, originalException: any, originalStack: any,\n    key: ReflectiveKey) {\n    super('DI Error', originalException);\n    this.keys = [key];\n    this.injectors = [injector];\n  }\n/**\n * @param {?} injector\n * @param {?} key\n * @return {?}\n */\naddKey(injector: ReflectiveInjector, key: ReflectiveKey): void {\n    this.injectors.push(injector);\n    this.keys.push(key);\n  }\n/**\n * @return {?}\n */\nget message(): string {\n    const /** @type {?} */ first = stringify(this.keys[0].token);\n    return `${this.originalError.message}: Error during instantiation ` +\n      `of ${first}!${constructResolvingPath(this.keys)}.`;\n  }\n/**\n * @return {?}\n */\nget causeKey(): ReflectiveKey { return this.keys[0]; }\n}\n\nfunction InstantiationError_tsickle_Closure_declarations() {\n/**\n * \\@internal\n * @type {?}\n */\nInstantiationError.prototype.keys;\n/**\n * \\@internal\n * @type {?}\n */\nInstantiationError.prototype.injectors;\n}\n\n/**\n * Thrown when an object other then {\\@link Provider} (or `Type`) is passed to {\\@link Injector}\n * creation.\n * \n * ### Example ([live demo](http://plnkr.co/edit/YatCFbPAMCL0JSSQ4mvH?p=preview))\n * \n * ```typescript\n * expect(() => Injector.resolveAndCreate([\"not a type\"])).toThrowError();\n * ```\n * \\@stable\n */\nexport class InvalidProviderError extends BaseError {\n/**\n * @param {?} provider\n */\nconstructor(provider: any) {\n    super(`Invalid provider - only instances of Provider and Type are allowed, got: ${provider}`);\n  }\n}\n/**\n * Thrown when the class has no annotation information.\n * \n * Lack of annotation information prevents the {\\@link Injector} from determining which dependencies\n * need to be injected into the constructor.\n * \n * ### Example ([live demo](http://plnkr.co/edit/rHnZtlNS7vJOPQ6pcVkm?p=preview))\n * \n * ```typescript\n * class A {\n *   constructor(b) {}\n * }\n * \n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n * \n * This error is also thrown when the class not marked with {\\@link Injectable} has parameter types.\n * \n * ```typescript\n * class B {}\n * \n * class A {\n *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.\n * }\n * \n * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();\n * ```\n * \\@stable\n */\nexport class NoAnnotationError extends BaseError {\n/**\n * @param {?} typeOrFunc\n * @param {?} params\n */\nconstructor(typeOrFunc: ClassType<any> | Function, params: any[][]) {\n    super(NoAnnotationError._genMessage(typeOrFunc, params));\n  }\n/**\n * @param {?} typeOrFunc\n * @param {?} params\n * @return {?}\n */\nprivate static _genMessage(typeOrFunc: ClassType<any> | Function, params: any[][]) {\n    const /** @type {?} */ signature: string[] = [];\n    for (let /** @type {?} */ i = 0, /** @type {?} */ ii = params.length; i < ii; i++) {\n      const /** @type {?} */ parameter = params[i];\n      if (!parameter || parameter.length == 0) {\n        signature.push('?');\n      } else {\n        signature.push(parameter.map(stringify).join(' '));\n      }\n    }\n    return 'Cannot resolve all parameters for \\'' + stringify(typeOrFunc) + '\\'(' +\n      signature.join(', ') + '). ' +\n      'Make sure that all the parameters are decorated with Inject or have valid type ' +\n      'annotations and that \\'' + stringify(typeOrFunc) + '\\' is decorated with Injectable.';\n  }\n}\n/**\n * Thrown when getting an object by index.\n * \n * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))\n * \n * ```typescript\n * class A {}\n * \n * var injector = Injector.resolveAndCreate([A]);\n * \n * expect(() => injector.getAt(100)).toThrowError();\n * ```\n * \\@stable\n */\nexport class OutOfBoundsError extends BaseError {\n/**\n * @param {?} index\n */\nconstructor(index: number) { super(`Index ${index} is out-of-bounds.`); }\n}\n/**\n * Thrown when a multi provider and a regular provider are bound to the same token.\n * \n * ### Example\n * \n * ```typescript\n * expect(() => Injector.resolveAndCreate([\n *   { provide: \"Strings\", useValue: \"string1\", multi: true},\n *   { provide: \"Strings\", useValue: \"string2\", multi: false}\n * ])).toThrowError();\n * ```\n */\nexport class MixingMultiProvidersWithRegularProvidersError extends BaseError {\n/**\n * @param {?} provider1\n * @param {?} provider2\n */\nconstructor(provider1: any, provider2: any) {\n    super(\n      'Cannot mix multi providers and regular providers, got: ' + provider1.toString() + ' ' +\n      provider2.toString());\n  }\n}\n","import { stringify } from '../facade/lang';\nimport { ClassType } from '../type';\nimport { InjectionToken } from './injection_token';\n\nconst /** @type {?} */ _THROW_IF_NOT_FOUND = new Object();\nexport const /** @type {?} */ THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\nclass _NullInjector implements Injector {\n/**\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget(token: any, notFoundValue: any = _THROW_IF_NOT_FOUND): any {\n    if (notFoundValue === _THROW_IF_NOT_FOUND) {\n      throw new Error(`No provider for ${stringify(token)}!`);\n    }\n    return notFoundValue;\n  }\n}\n/**\n * \\@whatItDoes Injector interface\n * \\@howToUse \n * ```\n * const injector: Injector = ...;\n * injector.get(...);\n * ```\n * \n * \\@description \n * For more details, see the {\\@linkDocs guide/dependency-injection \"Dependency Injection Guide\"}.\n * \n * ### Example\n * \n * {\\@example core/di/ts/injector_spec.ts region='Injector'}\n * \n * `Injector` returns itself when given `Injector` as a token:\n * {\\@example core/di/ts/injector_spec.ts region='injectInjector'}\n * \n * \\@stable\n * @abstract\n */\nexport abstract class Injector {\n  static THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n  static NULL: Injector = new _NullInjector();\n/**\n * Retrieves an instance from the injector based on the provided token.\n * If not found:\n * - Throws {\\@link NoProviderError} if no `notFoundValue` that is not equal to\n * Injector.THROW_IF_NOT_FOUND is given\n * - Returns the `notFoundValue` otherwise\n * @abstract\n * @template T\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget<T>(token: Function | ClassType<T> | InjectionToken<T>, notFoundValue?: T) {}\n/**\n * @deprecated from v4.0.0 use Type<T> or InjectToken<T>\n * @suppress {duplicate}\n * @abstract\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget(token: any, notFoundValue?: any) {}\n}\n\nfunction Injector_tsickle_Closure_declarations() {\n/** @type {?} */\nInjector.THROW_IF_NOT_FOUND;\n/** @type {?} */\nInjector.NULL;\n}\n\n","import { BaseError } from '../facade/error';\nimport { stringify } from '../facade/lang';\nimport { ClassType } from '../type';\nexport class PlatformAlreadyExistsError extends BaseError {\nconstructor() {\n    super(`A platform already exists. Destroy it first before creating this one.`);\n  }\n}\n","\n/**\n * Convenience to throw an Error with 'unimplemented' as the message.\n * @return {?}\n */\nexport function unimplemented(): any {\n  throw new Error('unimplemented');\n}\nexport class BaseError extends Error {\n/**\n * \\@internal *\n */\n_nativeError: Error;\n/**\n * @param {?} message\n */\nconstructor(message: string) {\n    super(message);\n    // Errors don't use current this, instead they create a new instance.\n    // We have to do forward all of our api to the nativeInstance.\n    const nativeError = new Error(message) as any as Error;\n    this._nativeError = nativeError;\n  }\n/**\n * @return {?}\n */\nget message() { return this._nativeError.message; }\n/**\n * @param {?} message\n * @return {?}\n */\nset message(message) { this._nativeError.message = message; }\n/**\n * @return {?}\n */\nget name() { return this._nativeError.name; }\n/**\n * @return {?}\n */\nget stack() { return ( /** @type {?} */((this._nativeError as any))).stack; }\n/**\n * @param {?} value\n * @return {?}\n */\nset stack(value) { ( /** @type {?} */((this._nativeError as any))).stack = value; }\n/**\n * @return {?}\n */\ntoString() { return this._nativeError.toString(); }\n}\n\nfunction BaseError_tsickle_Closure_declarations() {\n/**\n * \\@internal *\n * @type {?}\n */\nBaseError.prototype._nativeError;\n}\n\nexport class WrappedError extends BaseError {\n  originalError: any;\n/**\n * @param {?} message\n * @param {?} error\n */\nconstructor(message: string, error: any) {\n    super(`${message} caused by: ${error instanceof Error ? error.message : error}`);\n    this.originalError = error;\n  }\n/**\n * @return {?}\n */\nget stack() {\n    return ( /** @type {?} */(((this.originalError instanceof Error ? this.originalError : this._nativeError) as any)))\n      .stack;\n  }\n}\n\nfunction WrappedError_tsickle_Closure_declarations() {\n/** @type {?} */\nWrappedError.prototype.originalError;\n}\n\n","import { ListWrapper, StringMapWrapper } from '../facade/collection';\nimport { stringify } from '../facade/lang';\nimport { ClassType } from '../type';\nimport { Component, HostListener, ChildListener } from './metadata';\nimport { reflector } from '../reflection/reflection';\nimport { ReflectorReader } from '../reflection/reflector_reader';\nimport { Injectable } from '../di/metadata';\nexport class ComponentResolver {\nprivate _resolved = new Map<ClassType<any>, Component>();\n/**\n * @param {?=} _reflector\n */\nconstructor(private _reflector: ReflectorReader = reflector) { }\n/**\n * Resolve the metadata of a Component.\n * \n * \\@memberOf ComponentResolver\n * @param {?} type\n * @param {?=} throwIfNotFound\n * @return {?} component metadata\n */\nresolve(type: ClassType<any>, throwIfNotFound = true): Component {\n    let /** @type {?} */ resolved = this._resolved.get(type);\n    if (resolved) {\n      return resolved;\n    }\n    const /** @type {?} */ metadata: Component =\n      ListWrapper.findLast(this._reflector.annotations(type), obj => obj instanceof Component);\n    if (metadata) {\n      const /** @type {?} */ propertyMetadata = this._reflector.propMetadata(type);\n      return this._mergeWithPropertyMetadata(metadata, propertyMetadata, type);\n    } else {\n      if (throwIfNotFound) {\n        throw new Error(`No Component metadata found for '${stringify(type)}'.`);\n      }\n      return null;\n    }\n  }\n/**\n * @param {?} meta\n * @param {?} propertyMetadata\n * @param {?} type\n * @return {?}\n */\nprivate _mergeWithPropertyMetadata(meta: Component, propertyMetadata: {[key: string]: any[]},\n      type: ClassType<any>): Component {\n    const /** @type {?} */ host: {[key: string]: string} = {};\n    const /** @type {?} */ childs: {[key: string]: string} = {};\n\n    Object.keys(propertyMetadata).forEach((propName: string) => {\n      const /** @type {?} */ hostListeners = propertyMetadata[propName]\n        .filter(a => a && a instanceof HostListener);\n      hostListeners.forEach(hostListener => {\n        const /** @type {?} */ args = hostListener.args || [];\n        host[`(${hostListener.eventName})`] = `${propName}(${args.join(',')})`;\n      });\n      const /** @type {?} */ childListeners = propertyMetadata[propName]\n        .filter(a => a && a instanceof ChildListener);\n      childListeners.forEach(childListener => {\n        const /** @type {?} */ args = childListener.args || [];\n        childs[`${childListener.selector};(${childListener.eventName})`] =\n          `${propName}(${args.join(',')})`;\n      });\n    });\n\n    const /** @type {?} */ resolved = new Component({\n      selector: meta.selector,\n      host: meta.host ? StringMapWrapper.merge(meta.host, host) : host,\n      childs: meta.childs ? StringMapWrapper.merge(meta.childs, childs) : childs,\n      providers: meta.providers,\n      components: meta.components\n    });\n    this._resolved.set(type, resolved);\n    return resolved;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ReflectorReader, },\n];\n}\n\nfunction ComponentResolver_tsickle_Closure_declarations() {\n/** @type {?} */\nComponentResolver.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nComponentResolver.ctorParameters;\n/** @type {?} */\nComponentResolver.prototype._resolved;\n/** @type {?} */\nComponentResolver.prototype._reflector;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Type} from '../type';\nimport {PlatformReflectionCapabilities} from './platform_reflection_capabilities';\nimport {ReflectorReader} from './reflector_reader';\nimport {GetterFn, MethodFn, SetterFn} from './types';\n\nexport {PlatformReflectionCapabilities} from './platform_reflection_capabilities';\nexport {GetterFn, MethodFn, SetterFn} from './types';\n/**\n * Provides access to reflection data about symbols. Used internally by Angular\n * to power dependency injection and compilation.\n */\nexport class Reflector extends ReflectorReader {\n/**\n * @param {?} reflectionCapabilities\n */\nconstructor(public reflectionCapabilities: PlatformReflectionCapabilities) { super(); }\n/**\n * @param {?} caps\n * @return {?}\n */\nupdateCapabilities(caps: PlatformReflectionCapabilities) { this.reflectionCapabilities = caps; }\n/**\n * @param {?} type\n * @return {?}\n */\nfactory(type: Type<any>): Function { return this.reflectionCapabilities.factory(type); }\n/**\n * @param {?} typeOrFunc\n * @return {?}\n */\nparameters(typeOrFunc: Type<any>): any[][] {\n    return this.reflectionCapabilities.parameters(typeOrFunc);\n  }\n/**\n * @param {?} typeOrFunc\n * @return {?}\n */\nannotations(typeOrFunc: Type<any>): any[] {\n    return this.reflectionCapabilities.annotations(typeOrFunc);\n  }\n/**\n * @param {?} typeOrFunc\n * @return {?}\n */\npropMetadata(typeOrFunc: Type<any>): {[key: string]: any[]} {\n    return this.reflectionCapabilities.propMetadata(typeOrFunc);\n  }\n/**\n * @param {?} type\n * @param {?} lcProperty\n * @return {?}\n */\nhasLifecycleHook(type: any, lcProperty: string): boolean {\n    return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);\n  }\n/**\n * @param {?} name\n * @return {?}\n */\ngetter(name: string): GetterFn { return this.reflectionCapabilities.getter(name); }\n/**\n * @param {?} name\n * @return {?}\n */\nsetter(name: string): SetterFn { return this.reflectionCapabilities.setter(name); }\n/**\n * @param {?} name\n * @return {?}\n */\nmethod(name: string): MethodFn { return this.reflectionCapabilities.method(name); }\n/**\n * @param {?} type\n * @return {?}\n */\nimportUri(type: any): string { return this.reflectionCapabilities.importUri(type); }\n/**\n * @param {?} type\n * @return {?}\n */\nresourceUri(type: any): string { return this.reflectionCapabilities.resourceUri(type); }\n/**\n * @param {?} name\n * @param {?} moduleUrl\n * @param {?} members\n * @param {?} runtime\n * @return {?}\n */\nresolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any {\n    return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, members, runtime);\n  }\n/**\n * @param {?} identifier\n * @param {?} name\n * @return {?}\n */\nresolveEnum(identifier: any, name: string): any {\n    return this.reflectionCapabilities.resolveEnum(identifier, name);\n  }\n}\n\nfunction Reflector_tsickle_Closure_declarations() {\n/** @type {?} */\nReflector.prototype.reflectionCapabilities;\n}\n\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {ReflectionCapabilities} from './reflection_capabilities';\nimport {Reflector} from './reflector';\n\nexport {Reflector} from './reflector';\n/**\n * The {\\@link Reflector} used internally in Angular to access metadata\n * about symbols.\n */\nexport const reflector = new Reflector(new ReflectionCapabilities());\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Type, isType} from '../type';\nimport {global, stringify} from '../facade/lang';\nimport {PlatformReflectionCapabilities} from './platform_reflection_capabilities';\nimport {GetterFn, MethodFn, SetterFn} from './types';\n/**\n * Attention: This regex has to hold even if the code is minified!\n */\nexport const DELEGATE_CTOR =\n    /^function\\s+\\S+\\(\\)\\s*{\\s*(\"use strict\";)?\\s*(return\\s+)?(\\S+\\s+!==\\s+null\\s+&&\\s+)?\\S+\\.apply\\(this,\\s*arguments\\)/;\nexport class ReflectionCapabilities implements PlatformReflectionCapabilities {\nprivate _reflect: any;\n/**\n * @param {?=} reflect\n */\nconstructor(reflect?: any) { this._reflect = reflect || global['Reflect']; }\n/**\n * @return {?}\n */\nisReflectionEnabled(): boolean { return true; }\n/**\n * @template T\n * @param {?} t\n * @return {?}\n */\nfactory<T>(t: Type<T>): (args: any[]) => T { return (...args: any[]) => new t(...args); }\n/**\n * \\@internal\n * @param {?} paramTypes\n * @param {?} paramAnnotations\n * @return {?}\n */\n_zipTypesAndAnnotations(paramTypes: any[], paramAnnotations: any[]): any[][] {\n    let /** @type {?} */ result: any[][];\n\n    if (typeof paramTypes === 'undefined') {\n      result = new Array(paramAnnotations.length);\n    } else {\n      result = new Array(paramTypes.length);\n    }\n\n    for (let /** @type {?} */ i = 0; i < result.length; i++) {\n      // TS outputs Object for parameters without types, while Traceur omits\n      // the annotations. For now we preserve the Traceur behavior to aid\n      // migration, but this can be revisited.\n      if (typeof paramTypes === 'undefined') {\n        result[i] = [];\n      } else if (paramTypes[i] != Object) {\n        result[i] = [paramTypes[i]];\n      } else {\n        result[i] = [];\n      }\n      if (paramAnnotations && paramAnnotations[i] != null) {\n        result[i] = result[i].concat(paramAnnotations[i]);\n      }\n    }\n    return result;\n  }\n/**\n * @param {?} type\n * @param {?} parentCtor\n * @return {?}\n */\nprivate _ownParameters(type: Type<any>, parentCtor: any): any[][] {\n    // If we have no decorators, we only have function.length as metadata.\n    // In that case, to detect whether a child class declared an own constructor or not,\n    // we need to look inside of that constructor to check whether it is\n    // just calling the parent.\n    // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\n    // that sets 'design:paramtypes' to []\n    // if a class inherits from another class but has no ctor declared itself.\n    if (DELEGATE_CTOR.exec(type.toString())) {\n      return null;\n    }\n\n    // Prefer the direct API.\n    if (( /** @type {?} */((<any>type))).parameters && ( /** @type {?} */((<any>type))).parameters !== parentCtor.parameters) {\n      return ( /** @type {?} */((<any>type))).parameters;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    const /** @type {?} */ tsickleCtorParams = ( /** @type {?} */((<any>type))).ctorParameters;\n    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\n      // Newer tsickle uses a function closure\n      // Retain the non-function case for compatibility with older tsickle\n      const /** @type {?} */ ctorParameters =\n          typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\n      const /** @type {?} */ paramTypes = ctorParameters.map((ctorParam: any) => ctorParam && ctorParam.type);\n      const /** @type {?} */ paramAnnotations = ctorParameters.map(\n          (ctorParam: any) =>\n              ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (this._reflect != null && this._reflect.getOwnMetadata != null) {\n      const /** @type {?} */ paramAnnotations = this._reflect.getOwnMetadata('parameters', type);\n      const /** @type {?} */ paramTypes = this._reflect.getOwnMetadata('design:paramtypes', type);\n      if (paramTypes || paramAnnotations) {\n        return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n      }\n    }\n\n    // If a class has no decorators, at least create metadata\n    // based on function.length.\n    // Note: We know that this is a real constructor as we checked\n    // the content of the constructor above.\n    return new Array(( /** @type {?} */((<any>type.length)))).fill(undefined);\n  }\n/**\n * @param {?} type\n * @return {?}\n */\nparameters(type: Type<any>): any[][] {\n    // Note: only report metadata if we have at least one class decorator\n    // to stay in sync with the static reflector.\n    if (!isType(type)) {\n      return [];\n    }\n    const /** @type {?} */ parentCtor = getParentCtor(type);\n    let /** @type {?} */ parameters = this._ownParameters(type, parentCtor);\n    if (!parameters && parentCtor !== Object) {\n      parameters = this.parameters(parentCtor);\n    }\n    return parameters || [];\n  }\n/**\n * @param {?} typeOrFunc\n * @param {?} parentCtor\n * @return {?}\n */\nprivate _ownAnnotations(typeOrFunc: Type<any>, parentCtor: any): any[] {\n    // Prefer the direct API.\n    if (( /** @type {?} */((<any>typeOrFunc))).annotations && ( /** @type {?} */((<any>typeOrFunc))).annotations !== parentCtor.annotations) {\n      let /** @type {?} */ annotations = ( /** @type {?} */((<any>typeOrFunc))).annotations;\n      if (typeof annotations === 'function' && annotations.annotations) {\n        annotations = annotations.annotations;\n      }\n      return annotations;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if (( /** @type {?} */((<any>typeOrFunc))).decorators && ( /** @type {?} */((<any>typeOrFunc))).decorators !== parentCtor.decorators) {\n      return convertTsickleDecoratorIntoMetadata(( /** @type {?} */((<any>typeOrFunc))).decorators);\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (this._reflect && this._reflect.getOwnMetadata) {\n      return this._reflect.getOwnMetadata('annotations', typeOrFunc);\n    }\n  }\n/**\n * @param {?} typeOrFunc\n * @return {?}\n */\nannotations(typeOrFunc: Type<any>): any[] {\n    if (!isType(typeOrFunc)) {\n      return [];\n    }\n    const /** @type {?} */ parentCtor = getParentCtor(typeOrFunc);\n    const /** @type {?} */ ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\n    const /** @type {?} */ parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\n    return parentAnnotations.concat(ownAnnotations);\n  }\n/**\n * @param {?} typeOrFunc\n * @param {?} parentCtor\n * @return {?}\n */\nprivate _ownPropMetadata(typeOrFunc: any, parentCtor: any): {[key: string]: any[]} {\n    // Prefer the direct API.\n    if (( /** @type {?} */((<any>typeOrFunc))).propMetadata &&\n        ( /** @type {?} */((<any>typeOrFunc))).propMetadata !== parentCtor.propMetadata) {\n      let /** @type {?} */ propMetadata = ( /** @type {?} */((<any>typeOrFunc))).propMetadata;\n      if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\n        propMetadata = propMetadata.propMetadata;\n      }\n      return propMetadata;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if (( /** @type {?} */((<any>typeOrFunc))).propDecorators &&\n        ( /** @type {?} */((<any>typeOrFunc))).propDecorators !== parentCtor.propDecorators) {\n      const /** @type {?} */ propDecorators = ( /** @type {?} */((<any>typeOrFunc))).propDecorators;\n      const /** @type {?} */ propMetadata = /** @type {?} */(( <{[key: string]: any[]}>{}));\n      Object.keys(propDecorators).forEach(prop => {\n        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);\n      });\n      return propMetadata;\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (this._reflect && this._reflect.getOwnMetadata) {\n      return this._reflect.getOwnMetadata('propMetadata', typeOrFunc);\n    }\n  }\n/**\n * @param {?} typeOrFunc\n * @return {?}\n */\npropMetadata(typeOrFunc: any): {[key: string]: any[]} {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    const /** @type {?} */ parentCtor = getParentCtor(typeOrFunc);\n    const /** @type {?} */ propMetadata: {[key: string]: any[]} = {};\n    if (parentCtor !== Object) {\n      const /** @type {?} */ parentPropMetadata = this.propMetadata(parentCtor);\n      Object.keys(parentPropMetadata).forEach((propName) => {\n        propMetadata[propName] = parentPropMetadata[propName];\n      });\n    }\n    const /** @type {?} */ ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\n    if (ownPropMetadata) {\n      Object.keys(ownPropMetadata).forEach((propName) => {\n        const /** @type {?} */ decorators: any[] = [];\n        if (propMetadata.hasOwnProperty(propName)) {\n          decorators.push(...propMetadata[propName]);\n        }\n        decorators.push(...ownPropMetadata[propName]);\n        propMetadata[propName] = decorators;\n      });\n    }\n    return propMetadata;\n  }\n/**\n * @param {?} type\n * @param {?} lcProperty\n * @return {?}\n */\nhasLifecycleHook(type: any, lcProperty: string): boolean {\n    return type instanceof Type && lcProperty in type.prototype;\n  }\n/**\n * @param {?} name\n * @return {?}\n */\ngetter(name: string): GetterFn { return /** @type {?} */(( <GetterFn>new Function('o', 'return o.' + name + ';'))); }\n/**\n * @param {?} name\n * @return {?}\n */\nsetter(name: string): SetterFn {\n    return /** @type {?} */(( <SetterFn>new Function('o', 'v', 'return o.' + name + ' = v;')));\n  }\n/**\n * @param {?} name\n * @return {?}\n */\nmethod(name: string): MethodFn {\n    const /** @type {?} */ functionBody = `if (!o.${name}) throw new Error('\"${name}\" is undefined');\n        return o.${name}.apply(o, args);`;\n    return /** @type {?} */(( <MethodFn>new Function('o', 'args', functionBody)));\n  }\n/**\n * @param {?} type\n * @return {?}\n */\nimportUri(type: any): string {\n    // StaticSymbol\n    if (typeof type === 'object' && type['filePath']) {\n      return type['filePath'];\n    }\n    // Runtime type\n    return `./${stringify(type)}`;\n  }\n/**\n * @param {?} type\n * @return {?}\n */\nresourceUri(type: any): string { return `./${stringify(type)}`; }\n/**\n * @param {?} name\n * @param {?} moduleUrl\n * @param {?} members\n * @param {?} runtime\n * @return {?}\n */\nresolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any {\n    return runtime;\n  }\n/**\n * @param {?} enumIdentifier\n * @param {?} name\n * @return {?}\n */\nresolveEnum(enumIdentifier: any, name: string): any { return enumIdentifier[name]; }\n}\n\nfunction ReflectionCapabilities_tsickle_Closure_declarations() {\n/** @type {?} */\nReflectionCapabilities.prototype._reflect;\n}\n\n/**\n * @param {?} decoratorInvocations\n * @return {?}\n */\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations: any[]): any[] {\n  if (!decoratorInvocations) {\n    return [];\n  }\n  return decoratorInvocations.map(decoratorInvocation => {\n    const /** @type {?} */ decoratorType = decoratorInvocation.type;\n    const /** @type {?} */ annotationCls = decoratorType.annotationCls;\n    const /** @type {?} */ annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n    return new annotationCls(...annotationArgs);\n  });\n}\n/**\n * @param {?} ctor\n * @return {?}\n */\nfunction getParentCtor(ctor: Function): Type<any> {\n  const /** @type {?} */ parentProto = Object.getPrototypeOf(ctor.prototype);\n  const /** @type {?} */ parentCtor = parentProto ? parentProto.constructor : null;\n  // Note: We always use `Object` as the null value\n  // to simplify checking later on.\n  return parentCtor || Object;\n}\n","export interface ClassType<T> extends Function {\n  new (...args: Array<any>): T;\n  constructor: Function | any[];\n  [propertyName: string]: any;\n  name: string;\n}\n/**\n * @param {?} instance\n * @return {?}\n */\nexport function isClassInstance(instance: any): boolean {\n  return typeof instance === 'object' && !!instance['constructor'];\n}\n\n// tslint:disable:variable-name\nexport const /** @type {?} */ Type = Function;\n/**\n * @param {?} v\n * @return {?}\n */\nexport function isType(v: any): v is Type<any> {\n  return typeof v === 'function';\n}\n\nexport interface Type<T> extends Function { new (...args: any[]): T; }\n","// tslint:disable:variable-name\n\n\nimport { makeDecorator, TypeDecorator, makePropDecorator } from '../utils/decorator';\nimport { stringify } from '../facade/lang';\nimport { ClassType } from '../type';\nimport { Provider } from '../di/provider';\n\n/** Type of the Component decorator / constructor function. */\nexport interface ComponentDecorator {\n  (obj: Component): TypeDecorator;\n  new (obj: Component): Component;\n}\n\n/** Type of the Component metadata. */\nexport interface Component {\n  /**\n   * The CSS selector that triggers the instantiation of a directive.\n   *\n   * Mojiito only allows components to trigger on CSS selectors that do not cross element\n   * boundaries.\n   *\n   * `selector` may be declared as one of the following:\n   *\n   * - `element-name`: select by element name.\n   * - `.class`: select by class name.\n   * - `[attribute]`: select by attribute name.\n   * - `[attribute=value]`: select by attribute name and value.\n   * - `:not(sub_selector)`: select only if the element does not match the `sub_selector`.\n   * - `selector1, selector2`: select if either `selector1` or `selector2` matches.\n   */\n  selector?: string;\n\n  /**\n   * Defines the set of injectable objects that are visible to a Components.\n   */\n  providers?: Provider[];\n\n  /**\n   * Defines a list of components which belong to this component and\n   * can be instantiated.\n   *\n   * When creating this component, mojiito will look for them in the\n   * DOM and create them if found.\n   */\n  components?: any[] | any[][];\n\n  /**\n   * Specify the events, actions, properties and attributes related to the host element.\n   */\n  host?: {[key: string]: string};\n\n  /**\n   * Specify the events, actions, properties and attributes related to child elements.\n   */\n  childs?: {[key: string]: string};\n}\n/**\n * Component decorator and metadata.\n * \n * \\@Annotation\n */\nexport const Component: ComponentDecorator = <ComponentDecorator>makeDecorator('Component', {\n  selector: undefined,\n  providers: undefined,\n  components: undefined,\n  host: undefined,\n  childs: undefined,\n});\n\n\n/** Type of the HostListener decorator / constructor function. */\nexport interface HostListenerDecorator {\n  /** Declares a host listener. */\n  (eventName: string, args?: string[]): any;\n  new (eventName: string, args?: string[]): any;\n}\n\n/** Type of the HostListener metadata. */\nexport interface HostListener {\n  eventName?: string;\n  args?: string[];\n}\n/**\n * HostListener decorator and metadata.\n * \n * \\@Annotation\n */\nexport const HostListener: HostListenerDecorator =\n    makePropDecorator('HostListener', [['eventName', undefined], ['args', []]]);\n\n/** Type of the ChildListener decorator / constructor function. */\nexport interface ChildListenerDecorator {\n  /** Declares a Child listener. */\n  (selector: string, eventName: string, args?: string[]): any;\n  new (selector: string, eventName: string, args?: string[]): any;\n}\n\n/** Type of the ChildListener metadata. */\nexport interface ChildListener {\n  selector?: string;\n  eventName?: string;\n  args?: string[];\n}\n/**\n * ChildListener decorator and metadata.\n * \n * \\@Annotation\n */\nexport const ChildListener: ChildListenerDecorator =\n    makePropDecorator('ChildListener', [\n      ['selector', undefined],\n      ['eventName', undefined],\n      ['args', []]\n    ]);\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport { global, stringify } from '../facade/lang';\nimport { ClassType } from '../type';\n\nlet /** @type {?} */ _nextClassId = 0;\nconst /** @type {?} */ Reflect = global.Reflect;\n\n\nexport interface TypeDecorator {\n  <T extends ClassType<any>>(type: T): T;\n  (target: Object, propertyKey?: string | symbol, parameterIndex?: number): void;\n  annotations: any[];\n  Class(obj: ClassType<any>): ClassType<any>;\n}\n/**\n * @param {?} annotation\n * @return {?}\n */\nfunction extractAnnotation(annotation: any): any {\n  if (typeof annotation === 'function' && annotation.hasOwnProperty('annotation')) {\n    // it is a decorator, extract annotation\n    annotation = annotation.annotation;\n  }\n  return annotation;\n}\n/**\n * @param {?} fnOrArray\n * @param {?} key\n * @return {?}\n */\nfunction applyParams(fnOrArray: (Function | any[]), key: string): Function {\n  if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||\n    fnOrArray === Number || fnOrArray === Array) {\n    throw new Error(`Can not use native ${stringify(fnOrArray)} as constructor`);\n  }\n\n  if (typeof fnOrArray === 'function') {\n    return fnOrArray;\n  }\n\n  if (Array.isArray(fnOrArray)) {\n    const /** @type {?} */ annotations: any[] = fnOrArray;\n    const /** @type {?} */ annoLength = annotations.length - 1;\n    const /** @type {?} */ fn: Function = fnOrArray[annoLength];\n    if (typeof fn !== 'function') {\n      throw new Error(`Last position of Class method array must be ` +\n        `Function in key ${key} was '${stringify(fn)}'`);\n    }\n    if (annoLength != fn.length) {\n      throw new Error(`Number of annotations (${annoLength}) does not match ` +\n        `number of arguments (${fn.length}) in the function: ${stringify(fn)}`);\n    }\n    const /** @type {?} */ paramsAnnotations: any[][] = [];\n    for (let /** @type {?} */ i = 0, /** @type {?} */ ii = annotations.length - 1; i < ii; i++) {\n      const /** @type {?} */ paramAnnotations: any[] = [];\n      paramsAnnotations.push(paramAnnotations);\n      const /** @type {?} */ annotation = annotations[i];\n      if (Array.isArray(annotation)) {\n        for (let /** @type {?} */ j = 0; j < annotation.length; j++) {\n          paramAnnotations.push(extractAnnotation(annotation[j]));\n        }\n      } else if (typeof annotation === 'function') {\n        paramAnnotations.push(extractAnnotation(annotation));\n      } else {\n        paramAnnotations.push(annotation);\n      }\n    }\n    Reflect.defineMetadata('parameters', paramsAnnotations, fn);\n    return fn;\n  }\n\n  throw new Error(`Only Function or Array is supported in Class ` +\n    `definition for key '${key}' is '${stringify(fnOrArray)}'`);\n}\n/**\n * @param {?} name\n * @param {?} props\n * @param {?=} parentClass\n * @param {?=} chainFn\n * @return {?}\n */\nexport function makeDecorator(\n  name: string, props: { [name: string]: any }, parentClass?: any,\n  chainFn: (fn: Function) => void = null): (...args: any[]) => (cls: any) => any {\n  const /** @type {?} */ metaCtor = makeMetadataCtor([props]);\n/**\n * @param {?} objOrType\n * @return {?}\n */\nfunction DecoratorFactory(objOrType: any): (cls: any) => any {\n    if (!(Reflect && Reflect.getOwnMetadata)) {\n      throw 'reflect-metadata shim is required when using class decorators';\n    }\n\n    if (this instanceof DecoratorFactory) {\n      metaCtor.call(this, objOrType);\n      return this;\n    }\n\n    const /** @type {?} */ annotationInstance = new ( /** @type {?} */((<any>DecoratorFactory)))(objOrType);\n    const /** @type {?} */ chainAnnotation =\n      typeof this === 'function' && Array.isArray(this.annotations) ? this.annotations : [];\n    chainAnnotation.push(annotationInstance);\n    // tslint:disable-next-line:variable-name\n    const /** @type {?} */ TypeDecorator: TypeDecorator = /** @type {?} */((\n      <TypeDecorator>function TypeDecorator(cls: ClassType<any>) {\n        const /** @type {?} */ annotations = Reflect.getOwnMetadata('annotations', cls) || [];\n        annotations.push(annotationInstance);\n        Reflect.defineMetadata('annotations', annotations, cls);\n        return cls;\n      }));\n    TypeDecorator.annotations = chainAnnotation;\n    // TypeDecorator.Class = Class;\n    if (chainFn) chainFn(TypeDecorator);\n    return TypeDecorator;\n  }\n\n  if (parentClass) {\n    DecoratorFactory.prototype = Object.create(parentClass.prototype);\n  }\n\n  DecoratorFactory.prototype.toString = () => `@${name}`;\n  ( /** @type {?} */((<any>DecoratorFactory))).annotationCls = DecoratorFactory;\n  return DecoratorFactory;\n}\n/**\n * @param {?} props\n * @return {?}\n */\nfunction makeMetadataCtor(props: ([string, any] | { [key: string]: any })[]): any {\n  return function ctor(...args: any[]) {\n    props.forEach((prop, i) => {\n      const /** @type {?} */ argVal = args[i];\n      if (Array.isArray(prop)) {\n        // plain parameter\n        this[prop[0]] = argVal === undefined ? prop[1] : argVal;\n      } else {\n        for (const /** @type {?} */ propName in prop) {\n          this[propName] =\n            argVal && argVal.hasOwnProperty(propName) ? argVal[propName] : prop[propName];\n        }\n      }\n    });\n  };\n}\n/**\n * @param {?} name\n * @param {?} props\n * @param {?=} parentClass\n * @return {?}\n */\nexport function makeParamDecorator(\n  name: string, props: ([string, any] | { [name: string]: any })[], parentClass?: any): any {\n  const /** @type {?} */ metaCtor = makeMetadataCtor(props);\n/**\n * @param {...?} args\n * @return {?}\n */\nfunction ParamDecoratorFactory(...args: any[]): any {\n    if (this instanceof ParamDecoratorFactory) {\n      metaCtor.apply(this, args);\n      return this;\n    }\n    const /** @type {?} */ annotationInstance = new ( /** @type {?} */((<any>ParamDecoratorFactory)))(...args);\n\n    ( /** @type {?} */((<any>ParamDecorator))).annotation = annotationInstance;\n    return ParamDecorator;\n/**\n * @param {?} cls\n * @param {?} unusedKey\n * @param {?} index\n * @return {?}\n */\nfunction ParamDecorator(cls: any, unusedKey: any, index: number): any {\n      const /** @type {?} */ parameters: any[][] = Reflect.getOwnMetadata('parameters', cls) || [];\n\n      // there might be gaps if some in between parameters do not have annotations.\n      // we pad with nulls.\n      while (parameters.length <= index) {\n        parameters.push(null);\n      }\n\n      parameters[index] = parameters[index] || [];\n      parameters[index].push(annotationInstance);\n\n      Reflect.defineMetadata('parameters', parameters, cls);\n      return cls;\n    }\n  }\n  if (parentClass) {\n    ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);\n  }\n  ParamDecoratorFactory.prototype.toString = () => `@${name}`;\n  ( /** @type {?} */((<any>ParamDecoratorFactory))).annotationCls = ParamDecoratorFactory;\n  return ParamDecoratorFactory;\n}\n/**\n * @param {?} name\n * @param {?} props\n * @param {?=} parentClass\n * @return {?}\n */\nexport function makePropDecorator(\n  name: string, props: ([string, any] | { [key: string]: any })[], parentClass?: any): any {\n  const /** @type {?} */ metaCtor = makeMetadataCtor(props);\n/**\n * @param {...?} args\n * @return {?}\n */\nfunction PropDecoratorFactory(...args: any[]): any {\n    if (this instanceof PropDecoratorFactory) {\n      metaCtor.apply(this, args);\n      return this;\n    }\n\n    const /** @type {?} */ decoratorInstance = new ( /** @type {?} */((<any>PropDecoratorFactory)))(...args);\n\n    // tslint:disable-next-line:no-shadowed-variable\n    return function PropDecorator(target: any, name: string) {\n      const /** @type {?} */ meta = Reflect.getOwnMetadata('propMetadata', target.constructor) || {};\n      meta[name] = meta.hasOwnProperty(name) && meta[name] || [];\n      meta[name].unshift(decoratorInstance);\n      Reflect.defineMetadata('propMetadata', meta, target.constructor);\n    };\n  }\n\n  if (parentClass) {\n    PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\n  }\n\n  PropDecoratorFactory.prototype.toString = () => `@${name}`;\n  ( /** @type {?} */((<any>PropDecoratorFactory))).annotationCls = PropDecoratorFactory;\n  return PropDecoratorFactory;\n}\n","\n/**\n * Returns the class name of a type.\n * \n * @export\n * @template T\n * @param {?} klass\n * @return {?}\n */\nexport function getClassName<T>(klass: Function) {\n  return ( /** @type {?} */((klass as any))).name ? ( /** @type {?} */((klass as any))).name :\n    /^function\\s+([\\w\\$]+)\\s*\\(/.exec(this.toString())[1];\n}\n/**\n * Tries to stringify a token. A token can be any type.\n * \n * @export\n * @param {?} token\n * @return {?}\n */\nexport function stringify(token: any): string {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (token === undefined || token === null) {\n    return '' + token;\n  }\n  if (token.name) {\n    return token.name;\n  }\n  if (token.overriddenName) {\n    return token.overriddenName;\n  }\n  if (typeof token === 'function') {\n      return getClassName(token);\n  }\n  if (token instanceof HTMLElement) {\n    let /** @type {?} */ parts = token.toString().match(/\\w+/g);\n    if (parts && parts.length) {\n      return parts[parts.length - 1];\n    }\n  }\n\n  var /** @type {?} */ res = token.toString();\n  var /** @type {?} */ newLineIndex = res.indexOf('\\n');\n  return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);\n}\n\nexport interface BrowserNodeGlobal {\n  Object: typeof Object;\n  Array: typeof Array;\n  Map: typeof Map;\n  Set: typeof Set;\n  Date: DateConstructor;\n  RegExp: RegExpConstructor;\n  JSON: typeof JSON;\n  Math: any;  // typeof Math;\n  assert(condition: any): void;\n  Reflect: any;\n  setTimeout: Function;\n  clearTimeout: Function;\n  setInterval: Function;\n  clearInterval: Function;\n  encodeURI: Function;\n}\n\ndeclare var WorkerGlobalScope: any;\ndeclare var global: any;\nlet /** @type {?} */ globalScope: BrowserNodeGlobal;\nif (typeof window === 'undefined') {\n  if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n    // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492\n    globalScope = /** @type {?} */(( <any>self));\n  } else {\n    globalScope = /** @type {?} */(( <any>global));\n  }\n} else {\n  globalScope = /** @type {?} */(( <any>window));\n}\nexport {globalScope as global};\n/**\n * @param {?} obj\n * @return {?}\n */\nexport function isPresent(obj: any): boolean {\n  return obj != null;\n}\n/**\n * @param {?} obj\n * @return {?}\n */\nexport function isBlank(obj: any): boolean {\n  return obj == null;\n}\nexport class NumberWrapper {\n/**\n * @param {?} text\n * @return {?}\n */\nstatic parseIntAutoRadix(text: string): number {\n    const /** @type {?} */ result: number = parseInt(text);\n    if (isNaN(result)) {\n      throw new Error('Invalid integer literal when parsing ' + text);\n    }\n    return result;\n  }\n/**\n * @param {?} value\n * @return {?}\n */\nstatic isNumeric(value: any): boolean { return !isNaN(value - parseFloat(value)); }\n}\n","\n/**\n * @license \n * Copyright Google Inc. All Rights Reserved.\n * \n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport class StringMapWrapper {\n/**\n * @template V\n * @param {?} m1\n * @param {?} m2\n * @return {?}\n */\nstatic merge<V>(m1: {[key: string]: V}, m2: {[key: string]: V}): {[key: string]: V} {\n    const /** @type {?} */ m: {[key: string]: V} = {};\n\n    for (const /** @type {?} */ k of Object.keys(m1)) {\n      m[k] = m1[k];\n    }\n\n    for (const /** @type {?} */ k of Object.keys(m2)) {\n      m[k] = m2[k];\n    }\n\n    return m;\n  }\n/**\n * @template V\n * @param {?} m1\n * @param {?} m2\n * @return {?}\n */\nstatic equals<V>(m1: {[key: string]: V}, m2: {[key: string]: V}): boolean {\n    const /** @type {?} */ k1 = Object.keys(m1);\n    const /** @type {?} */ k2 = Object.keys(m2);\n\n    if (k1.length != k2.length) {\n      return false;\n    }\n\n    for (let /** @type {?} */ i = 0; i < k1.length; i++) {\n      const /** @type {?} */ key = k1[i];\n      if (m1[key] !== m2[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\nexport class ListWrapper {\n/**\n * @template T\n * @param {?} arr\n * @param {?} condition\n * @return {?}\n */\nstatic findLast<T>(arr: T[], condition: (value: T) => boolean): T {\n    for (let /** @type {?} */ i = arr.length - 1; i >= 0; i--) {\n      if (condition(arr[i])) {\n        return arr[i];\n      }\n    }\n    return null;\n  }\n/**\n * @template T\n * @param {?} list\n * @param {?} items\n * @return {?}\n */\nstatic removeAll<T>(list: T[], items: T[]) {\n    for (let /** @type {?} */ i = 0; i < items.length; ++i) {\n      const /** @type {?} */ index = list.indexOf(items[i]);\n      if (index > -1) {\n        list.splice(index, 1);\n      }\n    }\n  }\n/**\n * @template T\n * @param {?} list\n * @param {?} el\n * @return {?}\n */\nstatic remove<T>(list: T[], el: T): boolean {\n    const /** @type {?} */ index = list.indexOf(el);\n    if (index > -1) {\n      list.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nstatic equals(a: any[], b: any[]): boolean {\n    if (a.length != b.length) return false;\n    for (let /** @type {?} */ i = 0; i < a.length; ++i) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n/**\n * @template T\n * @param {?} list\n * @return {?}\n */\nstatic flatten<T>(list: Array<T | T[]>): T[] {\n    return list.reduce((flat: any[], item: T | T[]): T[] => {\n      const /** @type {?} */ flatItem = Array.isArray(item) ? ListWrapper.flatten(item) : item;\n      return ( /** @type {?} */((<T[]>flat))).concat(flatItem);\n    }, []);\n  }\n/**\n * @template T\n * @param {?} list\n * @param {?} callback\n * @return {?}\n */\nstatic forEach<T>(list: ArrayLike<T>, callback: (item: T, index: number) => void): void {\n    for (let /** @type {?} */ i = 0, /** @type {?} */ max = list.length; i < max; i++) {\n      callback.call(callback, list[i], i);\n    }\n  }\n}\n"],"names":["ResolvedReflectiveFactory"],"mappings":"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"}