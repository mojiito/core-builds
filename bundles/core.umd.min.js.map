{"version":3,"file":"core.umd.min.js","sources":["../../../../packages/core/src/view/refs.ts","../../../../packages/core/src/view/view_ref.ts","../../../../packages/core/src/di/injection_token.ts","../../../../packages/core/src/core.ts","../../../../packages/core/src/reflection/reflection_capabilities.ts","../../../../packages/core/src/reflection/reflector.ts","../../../../packages/core/src/component/resolver.ts","../../../../packages/core/src/facade/error.ts","../../../../packages/core/src/di/injector.ts","../../../../packages/core/src/application/platform_errors.ts","../../../../packages/core/src/di/reflective_errors.ts","../../../../packages/core/src/di/reflective_key.ts","../../../../packages/core/src/di/reflective_provider.ts","../../../../packages/core/src/di/reflective_injector.ts","../../../../packages/core/src/application/platform.ts","../../../../packages/core/src/component/factory_resolver.ts","../../../../packages/core/src/component/factory.ts","../../../../packages/core/src/application/application.ts","../../../../packages/core/src/component/reference.ts","../../../../packages/core/src/view/view_container_ref.ts","../../../../packages/core/src/view/provider.ts","../../../../packages/core/src/view/utils.ts","../../../../packages/core/src/view/view.ts","../../../../packages/core/src/view/view_attach.ts","../../../../packages/core/src/facade/lang.ts","../../../../packages/core/src/facade/collection.ts","../../../../packages/core/src/utils/decorator.ts"],"sourcesContent":["// tslint:disable:class-name\n\nimport { ClassType } from '../type';\nimport { ApplicationRef } from '../application/application';\nimport { Renderer } from '../render';\nimport { Injector } from '../di/injector';\nimport { ComponentRef } from '../component/reference';\nimport { ComponentFactory } from '../component/factory';\nimport { createRootView, destroyView, initView } from './view';\nimport { ViewRef, InternalViewRef } from './view_ref';\nimport { ViewContainerRef } from './view_container_ref';\nimport { attachEmbeddedView, detachEmbeddedView } from './view_attach';\nimport { ElementRef } from './element_ref';\nimport {\n  ViewData, ViewDefinitionFactory, ViewDefinition, ViewState,\n  asProviderData, DepFlags, ViewContainerData\n} from './types';\nimport { resolveViewDefinition } from './utils';\nimport { resolveDep, tokenKey } from './provider';\n\nconst /** @type {?} */ EMPTY_CONTEXT = new Object();\n/**\n * @param {?} view\n * @return {?}\n */\nexport function createInjector(view: ViewData): Injector {\n  return new Injector_(view);\n}\n/**\n * Internal ComponentFactory\n */\nclass ComponentFactory_ extends ComponentFactory<any> {\n/**\n * @param {?} selector\n * @param {?} componentType\n * @param {?} _viewDefFactory\n */\nconstructor(public selector: string,\npublic componentType: ClassType<any>,\nprivate _viewDefFactory: ViewDefinitionFactory) {\n    super();\n  }\n/**\n * @param {?} injector\n * @param {?=} rootSelectorOrNode\n * @return {?}\n */\ncreate(injector: Injector, rootSelectorOrNode?: string | any): ComponentRef<any> {\n    const /** @type {?} */ viewDef = resolveViewDefinition(this._viewDefFactory);\n    const /** @type {?} */ componentNodeIndex = viewDef.componentProvider.index;\n    const /** @type {?} */ view = createRootView(viewDef, injector, rootSelectorOrNode, EMPTY_CONTEXT);\n    const /** @type {?} */ component = asProviderData(view, componentNodeIndex).instance;\n    return new ComponentRef_(view, new ViewRef_(view), component);\n  }\n}\n\nfunction ComponentFactory__tsickle_Closure_declarations() {\n/** @type {?} */\nComponentFactory_.prototype.selector;\n/** @type {?} */\nComponentFactory_.prototype.componentType;\n/** @type {?} */\nComponentFactory_.prototype._viewDefFactory;\n}\n\n/**\n * @param {?} selector\n * @param {?} componentType\n * @param {?} viewDefFactory\n * @return {?}\n */\nexport function createComponentFactory(selector: string, componentType: ClassType<any>,\n  viewDefFactory: ViewDefinitionFactory): ComponentFactory<any> {\n  return new ComponentFactory_(selector, componentType, viewDefFactory);\n}\n/**\n * Internal ComponentRef\n */\nclass ComponentRef_ extends ComponentRef<any> {\n/**\n * @param {?} _view\n * @param {?} _viewRef\n * @param {?} _component\n */\nconstructor(private _view: ViewData,\nprivate _viewRef: ViewRef,\nprivate _component: any) {\n    super();\n  }\n/**\n * @return {?}\n */\nget location(): ElementRef { return new ElementRef(null); }\n/**\n * @return {?}\n */\nget injector(): Injector { return new Injector_(this._view); }\n/**\n * @return {?}\n */\nget instance(): any { return this._component; };\n/**\n * @return {?}\n */\nget hostView(): ViewRef { return this._viewRef; };\n/**\n * @return {?}\n */\nget componentType(): ClassType<any> { return /** @type {?} */(( <any>this._component.constructor)); }\n/**\n * @return {?}\n */\ndestroy(): void { this._viewRef.destroy(); }\n/**\n * @param {?} callback\n * @return {?}\n */\nonDestroy(callback: Function): void { this._viewRef.onDestroy(callback); }\n}\n\nfunction ComponentRef__tsickle_Closure_declarations() {\n/** @type {?} */\nComponentRef_.prototype._view;\n/** @type {?} */\nComponentRef_.prototype._viewRef;\n/** @type {?} */\nComponentRef_.prototype._component;\n}\n\n/**\n * Internal ViewContainerRef\n */\nclass ViewContainerRef_ implements ViewContainerData {\n\n  /* @internal */\n  _embeddedViews: ViewData[] = [];\n/**\n * @param {?} _view\n */\nconstructor(private _view: ViewData) { }\n/**\n * @return {?}\n */\nget anchorElement(): ElementRef { return new ElementRef(this._view.renderElement); }\n/**\n * @return {?}\n */\nget injector(): Injector { return new Injector_(this._view); }\n/**\n * @return {?}\n */\nget parentInjector(): Injector {\n    let /** @type {?} */ view = this._view;\n    let /** @type {?} */ def = view.def;\n    while (!def && view) {\n      view = view.parent;\n      def = view.def;\n    }\n    return view ? new Injector_(view) : this._view.root.injector;\n  }\n/**\n * @return {?}\n */\nclear(): void { }\n/**\n * @param {?} index\n * @return {?}\n */\nget(index: number): ViewRef {\n    const /** @type {?} */ view = this._embeddedViews[index];\n    if (view) {\n      const /** @type {?} */ ref = new ViewRef_(view);\n      ref.attachToViewContainerRef(this);\n      return ref;\n    }\n    return null;\n  }\n/**\n * @return {?}\n */\nget length(): number { return 0; }\n/**\n * @template C\n * @param {?} templateRef\n * @param {?=} context\n * @param {?=} index\n * @return {?}\n */\ncreateEmbeddedView<C>(templateRef: any, context?: C, index?: number):\n    any { }\n/**\n * @template C\n * @param {?} componentFactory\n * @param {?=} index\n * @param {?=} injector\n * @param {?=} rootSelectorOrNode\n * @return {?}\n */\ncreateComponent<C>(componentFactory: ComponentFactory<C>, index?: number, injector?: Injector,\n    rootSelectorOrNode?: any): ComponentRef<C> {\n    const /** @type {?} */ contextInjector = injector || this.parentInjector;\n    const /** @type {?} */ componentRef = componentFactory.create(contextInjector, rootSelectorOrNode);\n    this.insert(componentRef.hostView, index);\n    return componentRef;\n  }\n/**\n * @param {?} viewRef\n * @param {?=} index\n * @return {?}\n */\ninsert(viewRef: ViewRef, index?: number): ViewRef {\n    // tslint:disable-next-line:variable-name\n    const /** @type {?} */ viewRef_ = /** @type {?} */(( <ViewRef_>viewRef));\n    const /** @type {?} */ viewData = viewRef_._view;\n    attachEmbeddedView(this._view, index, viewData);\n    viewRef_.attachToViewContainerRef(this);\n    return viewRef;\n  }\n/**\n * @param {?} viewRef\n * @return {?}\n */\nindexOf(viewRef: ViewRef): number {\n    return this._embeddedViews.indexOf(( /** @type {?} */((<ViewRef_>viewRef)))._view);\n  }\n/**\n * @param {?=} index\n * @return {?}\n */\nremove(index?: number): void {\n    const /** @type {?} */ view = detachEmbeddedView(this._view, index);\n    if (view) {\n      destroyView(view);\n    }\n  }\n/**\n * @param {?=} index\n * @return {?}\n */\ndetach(index?: number): ViewRef {\n    const /** @type {?} */ view = detachEmbeddedView(this._view, index);\n    return view ? new ViewRef_(view) : null;\n  }\n}\n\nfunction ViewContainerRef__tsickle_Closure_declarations() {\n/** @type {?} */\nViewContainerRef_.prototype._embeddedViews;\n/** @type {?} */\nViewContainerRef_.prototype._view;\n}\n\n/**\n * @param {?} view\n * @return {?}\n */\nexport function createViewContainerData(view: ViewData): ViewContainerData {\n  return new ViewContainerRef_(view);\n}\n/**\n * Internal View Reference\n */\nclass ViewRef_ implements InternalViewRef {\n  _view: ViewData;\nprivate _viewContainerRef: ViewContainerRef;\nprivate _appRef: ApplicationRef;\n/**\n * @param {?} _view\n */\nconstructor(_view: ViewData) {\n    this._view = _view;\n    this._viewContainerRef = null;\n    this._appRef = null;\n  }\n/**\n * @return {?}\n */\nget context() { return this._view.context; }\n/**\n * @return {?}\n */\nget destroyed(): boolean { return (this._view.state & ViewState.Destroyed) !== 0; }\n/**\n * @return {?}\n */\ndetach(): void { this._view.state &= ~ViewState.ChecksEnabled; }\n/**\n * @return {?}\n */\nreattach(): void { this._view.state |= ViewState.ChecksEnabled; }\n/**\n * @param {?} callback\n * @return {?}\n */\nonDestroy(callback: Function) {\n    if (!this._view.disposables) {\n      this._view.disposables = [];\n    }\n    this._view.disposables.push( /** @type {?} */((<any>callback)));\n  }\n/**\n * @return {?}\n */\ndestroy() {\n    if (this._appRef) {\n      this._appRef.detachView(this);\n    } else if (this._viewContainerRef) {\n      this._viewContainerRef.detach(this._viewContainerRef.indexOf(this));\n    }\n    destroyView(this._view);\n  }\n/**\n * @return {?}\n */\ndetachFromAppRef() {\n    this._appRef = null;\n  }\n/**\n * @param {?} appRef\n * @return {?}\n */\nattachToAppRef(appRef: ApplicationRef) {\n    if (this._viewContainerRef) {\n      throw new Error('This view is already attached to a ViewContainer!');\n    }\n    this._appRef = appRef;\n  }\n/**\n * @param {?} vcRef\n * @return {?}\n */\nattachToViewContainerRef(vcRef: ViewContainerRef) {\n    if (this._appRef) {\n      throw new Error('This view is already attached directly to the ApplicationRef!');\n    }\n    this._viewContainerRef = vcRef;\n  }\n}\n\nfunction ViewRef__tsickle_Closure_declarations() {\n/** @type {?} */\nViewRef_.prototype._view;\n/** @type {?} */\nViewRef_.prototype._viewContainerRef;\n/** @type {?} */\nViewRef_.prototype._appRef;\n}\n\n/**\n * Internal View Injector\n */\nclass Injector_ implements Injector {\n/**\n * @param {?} _view\n */\nconstructor(private _view: ViewData) { }\n/**\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget(token: any, notFoundValue: any = Injector.THROW_IF_NOT_FOUND): any {\n    return resolveDep(this._view,\n      {flags: DepFlags.None, token, tokenKey: tokenKey(token)}, notFoundValue);\n  }\n}\n\nfunction Injector__tsickle_Closure_declarations() {\n/** @type {?} */\nInjector_.prototype._view;\n}\n\n","import { ApplicationRef } from '../application/application';\n/**\n * @abstract\n */\nexport abstract class ViewRef {\n/**\n * Destroys the view and all of the data structures associated with it.\n * @abstract\n * @return {?}\n */\ndestroy() {}\n/**\n * @abstract\n * @return {?}\n */\ndestroyed() {}\n/**\n * @abstract\n * @param {?} callback\n * @return {?}\n */\nonDestroy(callback: Function) {}\n\n}\n\nexport interface InternalViewRef extends ViewRef {\n  detachFromAppRef(): void;\n  attachToAppRef(appRef: ApplicationRef): void;\n}\n","\n/**\n * Creates a token that can be used in a DI Provider.\n * \n * Use an `InjectionToken` whenever the type you are injecting is not reified (does not have a\n * runtime representation) such as when injecting an interface, callable type, array or\n * parametrized type.\n * \n * `InjectionToken` is parametrize on `T` which is the type of object which will be returned by the\n * `Injector`. This provides additional level of type safety.\n * \n * ```\n * interface MyInterface {...}\n * var myInterface = injector.get(new InjectionToken<MyInterface>('SomeToken'));\n * // myInterface is inferred to be MyInterface.\n * ```\n * \n * ### Example\n * \n * {\\@example core/di/ts/injector_spec.ts region='Injector'}\n * \n * \\@stable\n */\nexport class InjectionToken<T> {\n/**\n * @param {?} _desc\n */\nconstructor(protected _desc: string) {}\n/**\n * @return {?}\n */\ntoString(): string { return `InjectionToken ${this._desc}`; }\n}\n\nfunction InjectionToken_tsickle_Closure_declarations() {\n/** @type {?} */\nInjectionToken.prototype._desc;\n}\n\n","import { ComponentResolver } from './component/resolver';\nimport { reflector, Reflector } from './reflection/reflection';\nimport { ReflectorReader } from './reflection/reflector_reader';\nimport {\n  Provider, ClassProvider, ExistingProvider,\n  FactoryProvider, TypeProvider, ValueProvider,\n} from './di/provider';\n\n// Platform & Application\nexport { createPlatformFactory, getPlatform, PlatformRef } from './application/platform';\nexport { ApplicationRef } from './application/application';\n\n// Component\nexport { Component, HostListener, ChildListener } from './component/metadata';\nexport { ComponentResolver };\nexport { ComponentFactory } from './component/factory';\nexport { ComponentFactoryResolver } from './component/factory_resolver';\nexport { ComponentRef } from './component/reference';\n\n// View\nexport { createComponentFactory } from './view/refs';\nexport {NodeDef,ProviderDef,DepDef,DepFlags,ProviderData,asProviderData,ViewDefinition,ViewDefinitionFactory,NodeData,ViewData,ViewState,ViewContainerData,DisposableFn,RootData,NodeFlags} from './view/types';\nexport { ViewRef } from './view/view_ref';\nexport { ViewContainerRef } from './view/view_container_ref';\nexport { ElementRef } from './view/element_ref';\nexport { createViewDefinitionFactory, createView } from './view/view';\n\n// Dependency Injection\nexport { forwardRef } from './di/forward_ref';\nexport { InjectionToken } from './di/injection_token';\nexport { Injector } from './di/injector';\nexport { Host, Inject, Injectable, Optional, Self, SkipSelf } from './di/metadata';\nexport {\n  Provider, ClassProvider, ExistingProvider,\n  FactoryProvider, TypeProvider, ValueProvider\n};\nexport { ReflectiveInjector, ReflectiveInjector_ } from './di/reflective_injector';\nexport { ReflectiveKey } from './di/reflective_key';\nexport {\n  ReflectiveDependency, ResolvedReflectiveFactory, ResolvedReflectiveProvider,\n  ResolvedReflectiveProvider_, resolveReflectiveProviders, mergeResolvedReflectiveProviders,\n  constructDependencies\n} from './di/reflective_provider';\nexport { reflector, ReflectorReader, Reflector };\n\n// Others\nexport { ClassType, Type } from './type';\nexport { Renderer, RendererFactory, RendererType, Visitor } from './render';\n\n// Providers\nexport const /** @type {?} */ CORE_PROVIDERS: Provider[] = [\n  { provide: ReflectorReader, useValue: reflector },\n  ComponentResolver\n];\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Type, isType} from '../type';\nimport {global, stringify} from '../facade/lang';\nimport {PlatformReflectionCapabilities} from './platform_reflection_capabilities';\nimport {GetterFn, MethodFn, SetterFn} from './types';\n/**\n * Attention: This regex has to hold even if the code is minified!\n */\nexport const DELEGATE_CTOR =\n    /^function\\s+\\S+\\(\\)\\s*{\\s*(\"use strict\";)?\\s*(return\\s+)?(\\S+\\s+!==\\s+null\\s+&&\\s+)?\\S+\\.apply\\(this,\\s*arguments\\)/;\nexport class ReflectionCapabilities implements PlatformReflectionCapabilities {\nprivate _reflect: any;\n/**\n * @param {?=} reflect\n */\nconstructor(reflect?: any) { this._reflect = reflect || global['Reflect']; }\n/**\n * @return {?}\n */\nisReflectionEnabled(): boolean { return true; }\n/**\n * @template T\n * @param {?} t\n * @return {?}\n */\nfactory<T>(t: Type<T>): (args: any[]) => T { return (...args: any[]) => new t(...args); }\n/**\n * \\@internal\n * @param {?} paramTypes\n * @param {?} paramAnnotations\n * @return {?}\n */\n_zipTypesAndAnnotations(paramTypes: any[], paramAnnotations: any[]): any[][] {\n    let /** @type {?} */ result: any[][];\n\n    if (typeof paramTypes === 'undefined') {\n      result = new Array(paramAnnotations.length);\n    } else {\n      result = new Array(paramTypes.length);\n    }\n\n    for (let /** @type {?} */ i = 0; i < result.length; i++) {\n      // TS outputs Object for parameters without types, while Traceur omits\n      // the annotations. For now we preserve the Traceur behavior to aid\n      // migration, but this can be revisited.\n      if (typeof paramTypes === 'undefined') {\n        result[i] = [];\n      } else if (paramTypes[i] != Object) {\n        result[i] = [paramTypes[i]];\n      } else {\n        result[i] = [];\n      }\n      if (paramAnnotations && paramAnnotations[i] != null) {\n        result[i] = result[i].concat(paramAnnotations[i]);\n      }\n    }\n    return result;\n  }\n/**\n * @param {?} type\n * @param {?} parentCtor\n * @return {?}\n */\nprivate _ownParameters(type: Type<any>, parentCtor: any): any[][] {\n    // If we have no decorators, we only have function.length as metadata.\n    // In that case, to detect whether a child class declared an own constructor or not,\n    // we need to look inside of that constructor to check whether it is\n    // just calling the parent.\n    // This also helps to work around for https://github.com/Microsoft/TypeScript/issues/12439\n    // that sets 'design:paramtypes' to []\n    // if a class inherits from another class but has no ctor declared itself.\n    if (DELEGATE_CTOR.exec(type.toString())) {\n      return null;\n    }\n\n    // Prefer the direct API.\n    if (( /** @type {?} */((<any>type))).parameters && ( /** @type {?} */((<any>type))).parameters !== parentCtor.parameters) {\n      return ( /** @type {?} */((<any>type))).parameters;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    const /** @type {?} */ tsickleCtorParams = ( /** @type {?} */((<any>type))).ctorParameters;\n    if (tsickleCtorParams && tsickleCtorParams !== parentCtor.ctorParameters) {\n      // Newer tsickle uses a function closure\n      // Retain the non-function case for compatibility with older tsickle\n      const /** @type {?} */ ctorParameters =\n          typeof tsickleCtorParams === 'function' ? tsickleCtorParams() : tsickleCtorParams;\n      const /** @type {?} */ paramTypes = ctorParameters.map((ctorParam: any) => ctorParam && ctorParam.type);\n      const /** @type {?} */ paramAnnotations = ctorParameters.map(\n          (ctorParam: any) =>\n              ctorParam && convertTsickleDecoratorIntoMetadata(ctorParam.decorators));\n      return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (this._reflect != null && this._reflect.getOwnMetadata != null) {\n      const /** @type {?} */ paramAnnotations = this._reflect.getOwnMetadata('parameters', type);\n      const /** @type {?} */ paramTypes = this._reflect.getOwnMetadata('design:paramtypes', type);\n      if (paramTypes || paramAnnotations) {\n        return this._zipTypesAndAnnotations(paramTypes, paramAnnotations);\n      }\n    }\n\n    // If a class has no decorators, at least create metadata\n    // based on function.length.\n    // Note: We know that this is a real constructor as we checked\n    // the content of the constructor above.\n    return new Array(( /** @type {?} */((<any>type.length)))).fill(undefined);\n  }\n/**\n * @param {?} type\n * @return {?}\n */\nparameters(type: Type<any>): any[][] {\n    // Note: only report metadata if we have at least one class decorator\n    // to stay in sync with the static reflector.\n    if (!isType(type)) {\n      return [];\n    }\n    const /** @type {?} */ parentCtor = getParentCtor(type);\n    let /** @type {?} */ parameters = this._ownParameters(type, parentCtor);\n    if (!parameters && parentCtor !== Object) {\n      parameters = this.parameters(parentCtor);\n    }\n    return parameters || [];\n  }\n/**\n * @param {?} typeOrFunc\n * @param {?} parentCtor\n * @return {?}\n */\nprivate _ownAnnotations(typeOrFunc: Type<any>, parentCtor: any): any[] {\n    // Prefer the direct API.\n    if (( /** @type {?} */((<any>typeOrFunc))).annotations && ( /** @type {?} */((<any>typeOrFunc))).annotations !== parentCtor.annotations) {\n      let /** @type {?} */ annotations = ( /** @type {?} */((<any>typeOrFunc))).annotations;\n      if (typeof annotations === 'function' && annotations.annotations) {\n        annotations = annotations.annotations;\n      }\n      return annotations;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if (( /** @type {?} */((<any>typeOrFunc))).decorators && ( /** @type {?} */((<any>typeOrFunc))).decorators !== parentCtor.decorators) {\n      return convertTsickleDecoratorIntoMetadata(( /** @type {?} */((<any>typeOrFunc))).decorators);\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (this._reflect && this._reflect.getOwnMetadata) {\n      return this._reflect.getOwnMetadata('annotations', typeOrFunc);\n    }\n  }\n/**\n * @param {?} typeOrFunc\n * @return {?}\n */\nannotations(typeOrFunc: Type<any>): any[] {\n    if (!isType(typeOrFunc)) {\n      return [];\n    }\n    const /** @type {?} */ parentCtor = getParentCtor(typeOrFunc);\n    const /** @type {?} */ ownAnnotations = this._ownAnnotations(typeOrFunc, parentCtor) || [];\n    const /** @type {?} */ parentAnnotations = parentCtor !== Object ? this.annotations(parentCtor) : [];\n    return parentAnnotations.concat(ownAnnotations);\n  }\n/**\n * @param {?} typeOrFunc\n * @param {?} parentCtor\n * @return {?}\n */\nprivate _ownPropMetadata(typeOrFunc: any, parentCtor: any): {[key: string]: any[]} {\n    // Prefer the direct API.\n    if (( /** @type {?} */((<any>typeOrFunc))).propMetadata &&\n        ( /** @type {?} */((<any>typeOrFunc))).propMetadata !== parentCtor.propMetadata) {\n      let /** @type {?} */ propMetadata = ( /** @type {?} */((<any>typeOrFunc))).propMetadata;\n      if (typeof propMetadata === 'function' && propMetadata.propMetadata) {\n        propMetadata = propMetadata.propMetadata;\n      }\n      return propMetadata;\n    }\n\n    // API of tsickle for lowering decorators to properties on the class.\n    if (( /** @type {?} */((<any>typeOrFunc))).propDecorators &&\n        ( /** @type {?} */((<any>typeOrFunc))).propDecorators !== parentCtor.propDecorators) {\n      const /** @type {?} */ propDecorators = ( /** @type {?} */((<any>typeOrFunc))).propDecorators;\n      const /** @type {?} */ propMetadata = /** @type {?} */(( <{[key: string]: any[]}>{}));\n      Object.keys(propDecorators).forEach(prop => {\n        propMetadata[prop] = convertTsickleDecoratorIntoMetadata(propDecorators[prop]);\n      });\n      return propMetadata;\n    }\n\n    // API for metadata created by invoking the decorators.\n    if (this._reflect && this._reflect.getOwnMetadata) {\n      return this._reflect.getOwnMetadata('propMetadata', typeOrFunc);\n    }\n  }\n/**\n * @param {?} typeOrFunc\n * @return {?}\n */\npropMetadata(typeOrFunc: any): {[key: string]: any[]} {\n    if (!isType(typeOrFunc)) {\n      return {};\n    }\n    const /** @type {?} */ parentCtor = getParentCtor(typeOrFunc);\n    const /** @type {?} */ propMetadata: {[key: string]: any[]} = {};\n    if (parentCtor !== Object) {\n      const /** @type {?} */ parentPropMetadata = this.propMetadata(parentCtor);\n      Object.keys(parentPropMetadata).forEach((propName) => {\n        propMetadata[propName] = parentPropMetadata[propName];\n      });\n    }\n    const /** @type {?} */ ownPropMetadata = this._ownPropMetadata(typeOrFunc, parentCtor);\n    if (ownPropMetadata) {\n      Object.keys(ownPropMetadata).forEach((propName) => {\n        const /** @type {?} */ decorators: any[] = [];\n        if (propMetadata.hasOwnProperty(propName)) {\n          decorators.push(...propMetadata[propName]);\n        }\n        decorators.push(...ownPropMetadata[propName]);\n        propMetadata[propName] = decorators;\n      });\n    }\n    return propMetadata;\n  }\n/**\n * @param {?} type\n * @param {?} lcProperty\n * @return {?}\n */\nhasLifecycleHook(type: any, lcProperty: string): boolean {\n    return type instanceof Type && lcProperty in type.prototype;\n  }\n/**\n * @param {?} name\n * @return {?}\n */\ngetter(name: string): GetterFn { return /** @type {?} */(( <GetterFn>new Function('o', 'return o.' + name + ';'))); }\n/**\n * @param {?} name\n * @return {?}\n */\nsetter(name: string): SetterFn {\n    return /** @type {?} */(( <SetterFn>new Function('o', 'v', 'return o.' + name + ' = v;')));\n  }\n/**\n * @param {?} name\n * @return {?}\n */\nmethod(name: string): MethodFn {\n    const /** @type {?} */ functionBody = `if (!o.${name}) throw new Error('\"${name}\" is undefined');\n        return o.${name}.apply(o, args);`;\n    return /** @type {?} */(( <MethodFn>new Function('o', 'args', functionBody)));\n  }\n/**\n * @param {?} type\n * @return {?}\n */\nimportUri(type: any): string {\n    // StaticSymbol\n    if (typeof type === 'object' && type['filePath']) {\n      return type['filePath'];\n    }\n    // Runtime type\n    return `./${stringify(type)}`;\n  }\n/**\n * @param {?} type\n * @return {?}\n */\nresourceUri(type: any): string { return `./${stringify(type)}`; }\n/**\n * @param {?} name\n * @param {?} moduleUrl\n * @param {?} members\n * @param {?} runtime\n * @return {?}\n */\nresolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any {\n    return runtime;\n  }\n/**\n * @param {?} enumIdentifier\n * @param {?} name\n * @return {?}\n */\nresolveEnum(enumIdentifier: any, name: string): any { return enumIdentifier[name]; }\n}\n\nfunction ReflectionCapabilities_tsickle_Closure_declarations() {\n/** @type {?} */\nReflectionCapabilities.prototype._reflect;\n}\n\n/**\n * @param {?} decoratorInvocations\n * @return {?}\n */\nfunction convertTsickleDecoratorIntoMetadata(decoratorInvocations: any[]): any[] {\n  if (!decoratorInvocations) {\n    return [];\n  }\n  return decoratorInvocations.map(decoratorInvocation => {\n    const /** @type {?} */ decoratorType = decoratorInvocation.type;\n    const /** @type {?} */ annotationCls = decoratorType.annotationCls;\n    const /** @type {?} */ annotationArgs = decoratorInvocation.args ? decoratorInvocation.args : [];\n    return new annotationCls(...annotationArgs);\n  });\n}\n/**\n * @param {?} ctor\n * @return {?}\n */\nfunction getParentCtor(ctor: Function): Type<any> {\n  const /** @type {?} */ parentProto = Object.getPrototypeOf(ctor.prototype);\n  const /** @type {?} */ parentCtor = parentProto ? parentProto.constructor : null;\n  // Note: We always use `Object` as the null value\n  // to simplify checking later on.\n  return parentCtor || Object;\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {Type} from '../type';\nimport {PlatformReflectionCapabilities} from './platform_reflection_capabilities';\nimport {ReflectorReader} from './reflector_reader';\nimport {GetterFn, MethodFn, SetterFn} from './types';\n\nexport {PlatformReflectionCapabilities} from './platform_reflection_capabilities';\nexport {GetterFn, MethodFn, SetterFn} from './types';\n/**\n * Provides access to reflection data about symbols. Used internally by Angular\n * to power dependency injection and compilation.\n */\nexport class Reflector extends ReflectorReader {\n/**\n * @param {?} reflectionCapabilities\n */\nconstructor(public reflectionCapabilities: PlatformReflectionCapabilities) { super(); }\n/**\n * @param {?} caps\n * @return {?}\n */\nupdateCapabilities(caps: PlatformReflectionCapabilities) { this.reflectionCapabilities = caps; }\n/**\n * @param {?} type\n * @return {?}\n */\nfactory(type: Type<any>): Function { return this.reflectionCapabilities.factory(type); }\n/**\n * @param {?} typeOrFunc\n * @return {?}\n */\nparameters(typeOrFunc: Type<any>): any[][] {\n    return this.reflectionCapabilities.parameters(typeOrFunc);\n  }\n/**\n * @param {?} typeOrFunc\n * @return {?}\n */\nannotations(typeOrFunc: Type<any>): any[] {\n    return this.reflectionCapabilities.annotations(typeOrFunc);\n  }\n/**\n * @param {?} typeOrFunc\n * @return {?}\n */\npropMetadata(typeOrFunc: Type<any>): {[key: string]: any[]} {\n    return this.reflectionCapabilities.propMetadata(typeOrFunc);\n  }\n/**\n * @param {?} type\n * @param {?} lcProperty\n * @return {?}\n */\nhasLifecycleHook(type: any, lcProperty: string): boolean {\n    return this.reflectionCapabilities.hasLifecycleHook(type, lcProperty);\n  }\n/**\n * @param {?} name\n * @return {?}\n */\ngetter(name: string): GetterFn { return this.reflectionCapabilities.getter(name); }\n/**\n * @param {?} name\n * @return {?}\n */\nsetter(name: string): SetterFn { return this.reflectionCapabilities.setter(name); }\n/**\n * @param {?} name\n * @return {?}\n */\nmethod(name: string): MethodFn { return this.reflectionCapabilities.method(name); }\n/**\n * @param {?} type\n * @return {?}\n */\nimportUri(type: any): string { return this.reflectionCapabilities.importUri(type); }\n/**\n * @param {?} type\n * @return {?}\n */\nresourceUri(type: any): string { return this.reflectionCapabilities.resourceUri(type); }\n/**\n * @param {?} name\n * @param {?} moduleUrl\n * @param {?} members\n * @param {?} runtime\n * @return {?}\n */\nresolveIdentifier(name: string, moduleUrl: string, members: string[], runtime: any): any {\n    return this.reflectionCapabilities.resolveIdentifier(name, moduleUrl, members, runtime);\n  }\n/**\n * @param {?} identifier\n * @param {?} name\n * @return {?}\n */\nresolveEnum(identifier: any, name: string): any {\n    return this.reflectionCapabilities.resolveEnum(identifier, name);\n  }\n}\n\nfunction Reflector_tsickle_Closure_declarations() {\n/** @type {?} */\nReflector.prototype.reflectionCapabilities;\n}\n\n","import { ListWrapper, StringMapWrapper } from '../facade/collection';\nimport { stringify } from '../facade/lang';\nimport { ClassType } from '../type';\nimport { Component, HostListener, ChildListener } from './metadata';\nimport { reflector } from '../reflection/reflection';\nimport { ReflectorReader } from '../reflection/reflector_reader';\nimport { Injectable } from '../di/metadata';\nexport class ComponentResolver {\nprivate _resolved = new Map<ClassType<any>, Component>();\n/**\n * @param {?=} _reflector\n */\nconstructor(private _reflector: ReflectorReader = reflector) { }\n/**\n * Resolve the metadata of a Component.\n * \n * \\@memberOf ComponentResolver\n * @param {?} type\n * @param {?=} throwIfNotFound\n * @return {?} component metadata\n */\nresolve(type: ClassType<any>, throwIfNotFound = true): Component {\n    let /** @type {?} */ resolved = this._resolved.get(type);\n    if (resolved) {\n      return resolved;\n    }\n    const /** @type {?} */ metadata: Component =\n      ListWrapper.findLast(this._reflector.annotations(type), obj => obj instanceof Component);\n    if (metadata) {\n      const /** @type {?} */ propertyMetadata = this._reflector.propMetadata(type);\n      return this._mergeWithPropertyMetadata(metadata, propertyMetadata, type);\n    } else {\n      if (throwIfNotFound) {\n        throw new Error(`No Component metadata found for '${stringify(type)}'.`);\n      }\n      return null;\n    }\n  }\n/**\n * @param {?} meta\n * @param {?} propertyMetadata\n * @param {?} type\n * @return {?}\n */\nprivate _mergeWithPropertyMetadata(meta: Component, propertyMetadata: {[key: string]: any[]},\n      type: ClassType<any>): Component {\n    const /** @type {?} */ host: {[key: string]: string} = {};\n    const /** @type {?} */ childs: {[key: string]: string} = {};\n\n    Object.keys(propertyMetadata).forEach((propName: string) => {\n      const /** @type {?} */ hostListeners = propertyMetadata[propName]\n        .filter(a => a && a instanceof HostListener);\n      hostListeners.forEach(hostListener => {\n        const /** @type {?} */ args = hostListener.args || [];\n        host[`(${hostListener.eventName})`] = `${propName}(${args.join(',')})`;\n      });\n      const /** @type {?} */ childListeners = propertyMetadata[propName]\n        .filter(a => a && a instanceof ChildListener);\n      childListeners.forEach(childListener => {\n        const /** @type {?} */ args = childListener.args || [];\n        childs[`${childListener.selector};(${childListener.eventName})`] =\n          `${propName}(${args.join(',')})`;\n      });\n    });\n\n    const /** @type {?} */ resolved = new Component({\n      selector: meta.selector,\n      host: meta.host ? StringMapWrapper.merge(meta.host, host) : host,\n      childs: meta.childs ? StringMapWrapper.merge(meta.childs, childs) : childs,\n      providers: meta.providers,\n      components: meta.components\n    });\n    this._resolved.set(type, resolved);\n    return resolved;\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: ReflectorReader, },\n];\n}\n\nfunction ComponentResolver_tsickle_Closure_declarations() {\n/** @type {?} */\nComponentResolver.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nComponentResolver.ctorParameters;\n/** @type {?} */\nComponentResolver.prototype._resolved;\n/** @type {?} */\nComponentResolver.prototype._reflector;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","\n/**\n * Convenience to throw an Error with 'unimplemented' as the message.\n * @return {?}\n */\nexport function unimplemented(): any {\n  throw new Error('unimplemented');\n}\nexport class BaseError extends Error {\n/**\n * \\@internal *\n */\n_nativeError: Error;\n/**\n * @param {?} message\n */\nconstructor(message: string) {\n    super(message);\n    // Errors don't use current this, instead they create a new instance.\n    // We have to do forward all of our api to the nativeInstance.\n    const nativeError = new Error(message) as any as Error;\n    this._nativeError = nativeError;\n  }\n/**\n * @return {?}\n */\nget message() { return this._nativeError.message; }\n/**\n * @param {?} message\n * @return {?}\n */\nset message(message) { this._nativeError.message = message; }\n/**\n * @return {?}\n */\nget name() { return this._nativeError.name; }\n/**\n * @return {?}\n */\nget stack() { return ( /** @type {?} */((this._nativeError as any))).stack; }\n/**\n * @param {?} value\n * @return {?}\n */\nset stack(value) { ( /** @type {?} */((this._nativeError as any))).stack = value; }\n/**\n * @return {?}\n */\ntoString() { return this._nativeError.toString(); }\n}\n\nfunction BaseError_tsickle_Closure_declarations() {\n/**\n * \\@internal *\n * @type {?}\n */\nBaseError.prototype._nativeError;\n}\n\nexport class WrappedError extends BaseError {\n  originalError: any;\n/**\n * @param {?} message\n * @param {?} error\n */\nconstructor(message: string, error: any) {\n    super(`${message} caused by: ${error instanceof Error ? error.message : error}`);\n    this.originalError = error;\n  }\n/**\n * @return {?}\n */\nget stack() {\n    return ( /** @type {?} */(((this.originalError instanceof Error ? this.originalError : this._nativeError) as any)))\n      .stack;\n  }\n}\n\nfunction WrappedError_tsickle_Closure_declarations() {\n/** @type {?} */\nWrappedError.prototype.originalError;\n}\n\n","import { stringify } from '../facade/lang';\nimport { ClassType } from '../type';\nimport { InjectionToken } from './injection_token';\n\nconst /** @type {?} */ _THROW_IF_NOT_FOUND = new Object();\nexport const /** @type {?} */ THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\nclass _NullInjector implements Injector {\n/**\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget(token: any, notFoundValue: any = _THROW_IF_NOT_FOUND): any {\n    if (notFoundValue === _THROW_IF_NOT_FOUND) {\n      throw new Error(`No provider for ${stringify(token)}!`);\n    }\n    return notFoundValue;\n  }\n}\n/**\n * \\@whatItDoes Injector interface\n * \\@howToUse \n * ```\n * const injector: Injector = ...;\n * injector.get(...);\n * ```\n * \n * \\@description \n * For more details, see the {\\@linkDocs guide/dependency-injection \"Dependency Injection Guide\"}.\n * \n * ### Example\n * \n * {\\@example core/di/ts/injector_spec.ts region='Injector'}\n * \n * `Injector` returns itself when given `Injector` as a token:\n * {\\@example core/di/ts/injector_spec.ts region='injectInjector'}\n * \n * \\@stable\n * @abstract\n */\nexport abstract class Injector {\n  static THROW_IF_NOT_FOUND = _THROW_IF_NOT_FOUND;\n  static NULL: Injector = new _NullInjector();\n/**\n * Retrieves an instance from the injector based on the provided token.\n * If not found:\n * - Throws {\\@link NoProviderError} if no `notFoundValue` that is not equal to\n * Injector.THROW_IF_NOT_FOUND is given\n * - Returns the `notFoundValue` otherwise\n * @abstract\n * @template T\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget<T>(token: Function | ClassType<T> | InjectionToken<T>, notFoundValue?: T) {}\n/**\n * @deprecated from v4.0.0 use Type<T> or InjectToken<T>\n * @suppress {duplicate}\n * @abstract\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget(token: any, notFoundValue?: any) {}\n}\n\nfunction Injector_tsickle_Closure_declarations() {\n/** @type {?} */\nInjector.THROW_IF_NOT_FOUND;\n/** @type {?} */\nInjector.NULL;\n}\n\n","import { BaseError } from '../facade/error';\nimport { stringify } from '../facade/lang';\nimport { ClassType } from '../type';\nexport class PlatformAlreadyExistsError extends BaseError {\nconstructor() {\n    super(`A platform already exists. Destroy it first before creating this one.`);\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport { BaseError, WrappedError } from '../facade/error';\nimport { stringify } from '../facade/lang';\nimport { ClassType } from '../type';\n\nimport { ReflectiveInjector } from './reflective_injector';\nimport { ReflectiveKey } from './reflective_key';\n/**\n * @param {?} keys\n * @return {?}\n */\nfunction findFirstClosedCycle(keys: any[]): any[] {\n  const /** @type {?} */ res: any[] = [];\n  for (let /** @type {?} */ i = 0; i < keys.length; ++i) {\n    if (res.indexOf(keys[i]) > -1) {\n      res.push(keys[i]);\n      return res;\n    }\n    res.push(keys[i]);\n  }\n  return res;\n}\n/**\n * @param {?} keys\n * @return {?}\n */\nfunction constructResolvingPath(keys: any[]): string {\n  if (keys.length > 1) {\n    const /** @type {?} */ reversed = findFirstClosedCycle(keys.slice().reverse());\n    const /** @type {?} */ tokenStrs = reversed.map(k => stringify(k.token));\n    return ' (' + tokenStrs.join(' -> ') + ')';\n  }\n\n  return '';\n}\n/**\n * Base class for all errors arising from misconfigured providers.\n * \\@stable\n */\nexport class AbstractProviderError extends BaseError {\n/**\n * \\@internal\n */\nmessage: string;\n/**\n * \\@internal\n */\nkeys: ReflectiveKey[];\n/**\n * \\@internal\n */\ninjectors: ReflectiveInjector[];\n/**\n * \\@internal\n */\nconstructResolvingMessage: Function;\n/**\n * @param {?} injector\n * @param {?} key\n * @param {?} constructResolvingMessage\n */\nconstructor(\n    injector: ReflectiveInjector, key: ReflectiveKey, constructResolvingMessage: Function) {\n    super('DI Error');\n    this.keys = [key];\n    this.injectors = [injector];\n    this.constructResolvingMessage = constructResolvingMessage;\n    this.message = this.constructResolvingMessage(this.keys);\n  }\n/**\n * @param {?} injector\n * @param {?} key\n * @return {?}\n */\naddKey(injector: ReflectiveInjector, key: ReflectiveKey): void {\n    this.injectors.push(injector);\n    this.keys.push(key);\n    this.message = this.constructResolvingMessage(this.keys);\n  }\n}\n\nfunction AbstractProviderError_tsickle_Closure_declarations() {\n/**\n * \\@internal\n * @type {?}\n */\nAbstractProviderError.prototype.message;\n/**\n * \\@internal\n * @type {?}\n */\nAbstractProviderError.prototype.keys;\n/**\n * \\@internal\n * @type {?}\n */\nAbstractProviderError.prototype.injectors;\n/**\n * \\@internal\n * @type {?}\n */\nAbstractProviderError.prototype.constructResolvingMessage;\n}\n\n/**\n * Thrown when trying to retrieve a dependency by key from {\\@link Injector}, but the\n * {\\@link Injector} does not have a {\\@link Provider} for the given key.\n * \n * ### Example ([live demo](http://plnkr.co/edit/vq8D3FRB9aGbnWJqtEPE?p=preview))\n * \n * ```typescript\n * class A {\n *   constructor(b:B) {}\n * }\n * \n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n * \\@stable\n */\nexport class NoProviderError extends AbstractProviderError {\n/**\n * @param {?} injector\n * @param {?} key\n */\nconstructor(injector: ReflectiveInjector, key: ReflectiveKey) {\n    super(injector, key, function (keys: any[]) {\n      const first = stringify(keys[0].token);\n      return `No provider for ${first}!${constructResolvingPath(keys)}`;\n    });\n  }\n}\n/**\n * Thrown when dependencies form a cycle.\n * \n * ### Example ([live demo](http://plnkr.co/edit/wYQdNos0Tzql3ei1EV9j?p=info))\n * \n * ```typescript\n * var injector = Injector.resolveAndCreate([\n *   {provide: \"one\", useFactory: (two) => \"two\", deps: [[new Inject(\"two\")]]},\n *   {provide: \"two\", useFactory: (one) => \"one\", deps: [[new Inject(\"one\")]]}\n * ]);\n * \n * expect(() => injector.get(\"one\")).toThrowError();\n * ```\n * \n * Retrieving `A` or `B` throws a `CyclicDependencyError` as the graph above cannot be constructed.\n * \\@stable\n */\nexport class CyclicDependencyError extends AbstractProviderError {\n/**\n * @param {?} injector\n * @param {?} key\n */\nconstructor(injector: ReflectiveInjector, key: ReflectiveKey) {\n    super(injector, key, function (keys: any[]) {\n      return `Cannot instantiate cyclic dependency!${constructResolvingPath(keys)}`;\n    });\n  }\n}\n/**\n * Thrown when a constructing type returns with an Error.\n * \n * The `InstantiationError` class contains the original error plus the dependency graph which caused\n * this object to be instantiated.\n * \n * ### Example ([live demo](http://plnkr.co/edit/7aWYdcqTQsP0eNqEdUAf?p=preview))\n * \n * ```typescript\n * class A {\n *   constructor() {\n *     throw new Error('message');\n *   }\n * }\n * \n * var injector = Injector.resolveAndCreate([A]);\n * try {\n *   injector.get(A);\n * } catch (e) {\n *   expect(e instanceof InstantiationError).toBe(true);\n *   expect(e.originalException.message).toEqual(\"message\");\n *   expect(e.originalStack).toBeDefined();\n * }\n * ```\n * \\@stable\n */\nexport class InstantiationError extends WrappedError {\n/**\n * \\@internal\n */\nkeys: ReflectiveKey[];\n/**\n * \\@internal\n */\ninjectors: ReflectiveInjector[];\n/**\n * @param {?} injector\n * @param {?} originalException\n * @param {?} originalStack\n * @param {?} key\n */\nconstructor(\n    injector: ReflectiveInjector, originalException: any, originalStack: any,\n    key: ReflectiveKey) {\n    super('DI Error', originalException);\n    this.keys = [key];\n    this.injectors = [injector];\n  }\n/**\n * @param {?} injector\n * @param {?} key\n * @return {?}\n */\naddKey(injector: ReflectiveInjector, key: ReflectiveKey): void {\n    this.injectors.push(injector);\n    this.keys.push(key);\n  }\n/**\n * @return {?}\n */\nget message(): string {\n    const /** @type {?} */ first = stringify(this.keys[0].token);\n    return `${this.originalError.message}: Error during instantiation ` +\n      `of ${first}!${constructResolvingPath(this.keys)}.`;\n  }\n/**\n * @return {?}\n */\nget causeKey(): ReflectiveKey { return this.keys[0]; }\n}\n\nfunction InstantiationError_tsickle_Closure_declarations() {\n/**\n * \\@internal\n * @type {?}\n */\nInstantiationError.prototype.keys;\n/**\n * \\@internal\n * @type {?}\n */\nInstantiationError.prototype.injectors;\n}\n\n/**\n * Thrown when an object other then {\\@link Provider} (or `Type`) is passed to {\\@link Injector}\n * creation.\n * \n * ### Example ([live demo](http://plnkr.co/edit/YatCFbPAMCL0JSSQ4mvH?p=preview))\n * \n * ```typescript\n * expect(() => Injector.resolveAndCreate([\"not a type\"])).toThrowError();\n * ```\n * \\@stable\n */\nexport class InvalidProviderError extends BaseError {\n/**\n * @param {?} provider\n */\nconstructor(provider: any) {\n    super(`Invalid provider - only instances of Provider and Type are allowed, got: ${provider}`);\n  }\n}\n/**\n * Thrown when the class has no annotation information.\n * \n * Lack of annotation information prevents the {\\@link Injector} from determining which dependencies\n * need to be injected into the constructor.\n * \n * ### Example ([live demo](http://plnkr.co/edit/rHnZtlNS7vJOPQ6pcVkm?p=preview))\n * \n * ```typescript\n * class A {\n *   constructor(b) {}\n * }\n * \n * expect(() => Injector.resolveAndCreate([A])).toThrowError();\n * ```\n * \n * This error is also thrown when the class not marked with {\\@link Injectable} has parameter types.\n * \n * ```typescript\n * class B {}\n * \n * class A {\n *   constructor(b:B) {} // no information about the parameter types of A is available at runtime.\n * }\n * \n * expect(() => Injector.resolveAndCreate([A,B])).toThrowError();\n * ```\n * \\@stable\n */\nexport class NoAnnotationError extends BaseError {\n/**\n * @param {?} typeOrFunc\n * @param {?} params\n */\nconstructor(typeOrFunc: ClassType<any> | Function, params: any[][]) {\n    super(NoAnnotationError._genMessage(typeOrFunc, params));\n  }\n/**\n * @param {?} typeOrFunc\n * @param {?} params\n * @return {?}\n */\nprivate static _genMessage(typeOrFunc: ClassType<any> | Function, params: any[][]) {\n    const /** @type {?} */ signature: string[] = [];\n    for (let /** @type {?} */ i = 0, /** @type {?} */ ii = params.length; i < ii; i++) {\n      const /** @type {?} */ parameter = params[i];\n      if (!parameter || parameter.length == 0) {\n        signature.push('?');\n      } else {\n        signature.push(parameter.map(stringify).join(' '));\n      }\n    }\n    return 'Cannot resolve all parameters for \\'' + stringify(typeOrFunc) + '\\'(' +\n      signature.join(', ') + '). ' +\n      'Make sure that all the parameters are decorated with Inject or have valid type ' +\n      'annotations and that \\'' + stringify(typeOrFunc) + '\\' is decorated with Injectable.';\n  }\n}\n/**\n * Thrown when getting an object by index.\n * \n * ### Example ([live demo](http://plnkr.co/edit/bRs0SX2OTQiJzqvjgl8P?p=preview))\n * \n * ```typescript\n * class A {}\n * \n * var injector = Injector.resolveAndCreate([A]);\n * \n * expect(() => injector.getAt(100)).toThrowError();\n * ```\n * \\@stable\n */\nexport class OutOfBoundsError extends BaseError {\n/**\n * @param {?} index\n */\nconstructor(index: number) { super(`Index ${index} is out-of-bounds.`); }\n}\n/**\n * Thrown when a multi provider and a regular provider are bound to the same token.\n * \n * ### Example\n * \n * ```typescript\n * expect(() => Injector.resolveAndCreate([\n *   { provide: \"Strings\", useValue: \"string1\", multi: true},\n *   { provide: \"Strings\", useValue: \"string2\", multi: false}\n * ])).toThrowError();\n * ```\n */\nexport class MixingMultiProvidersWithRegularProvidersError extends BaseError {\n/**\n * @param {?} provider1\n * @param {?} provider2\n */\nconstructor(provider1: any, provider2: any) {\n    super(\n      'Cannot mix multi providers and regular providers, got: ' + provider1.toString() + ' ' +\n      provider2.toString());\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {stringify} from '../facade/lang';\nimport {resolveForwardRef} from './forward_ref';\n/**\n * A unique object used for retrieving items from the {\\@link ReflectiveInjector}.\n * \n * Keys have:\n * - a system-wide unique `id`.\n * - a `token`.\n * \n * `Key` is used internally by {\\@link ReflectiveInjector} because its system-wide unique `id` allows\n * the\n * injector to store created objects in a more efficient way.\n * \n * `Key` should not be created directly. {\\@link ReflectiveInjector} creates keys automatically when\n * resolving\n * providers.\n * \\@experimental\n */\nexport class ReflectiveKey {\n/**\n * Private\n * @param {?} token\n * @param {?} id\n */\nconstructor(public token: Object,\npublic id: number) {\n    if (!token) {\n      throw new Error('Token must be defined!');\n    }\n  }\n/**\n * Returns a stringified token.\n * @return {?}\n */\nget displayName(): string { return stringify(this.token); }\n/**\n * Retrieves a `Key` for a token.\n * @param {?} token\n * @return {?}\n */\nstatic get(token: Object): ReflectiveKey {\n    return _globalKeyRegistry.get(resolveForwardRef(token));\n  }\n/**\n * @return {?} the number of keys registered in the system.\n */\nstatic get numberOfKeys(): number { return _globalKeyRegistry.numberOfKeys; }\n}\n\nfunction ReflectiveKey_tsickle_Closure_declarations() {\n/** @type {?} */\nReflectiveKey.prototype.token;\n/** @type {?} */\nReflectiveKey.prototype.id;\n}\n\n/**\n * \\@internal\n */\nexport class KeyRegistry {\nprivate _allKeys = new Map<Object, ReflectiveKey>();\n/**\n * @param {?} token\n * @return {?}\n */\nget(token: Object): ReflectiveKey {\n    if (token instanceof ReflectiveKey) return token;\n\n    if (this._allKeys.has(token)) {\n      return this._allKeys.get(token);\n    }\n\n    const /** @type {?} */ newKey = new ReflectiveKey(token, ReflectiveKey.numberOfKeys);\n    this._allKeys.set(token, newKey);\n    return newKey;\n  }\n/**\n * @return {?}\n */\nget numberOfKeys(): number { return this._allKeys.size; }\n}\n\nfunction KeyRegistry_tsickle_Closure_declarations() {\n/** @type {?} */\nKeyRegistry.prototype._allKeys;\n}\n\n\nconst /** @type {?} */ _globalKeyRegistry = new KeyRegistry();\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport {reflector} from '../reflection/reflection';\nimport { ClassType } from '../type';\nimport { resolveForwardRef } from './forward_ref';\nimport { Inject, Optional, SkipSelf, Self } from './metadata';\nimport {\n  ClassProvider, ExistingProvider, FactoryProvider,\n  Provider, TypeProvider, ValueProvider\n} from './provider';\nimport {\n  InvalidProviderError, MixingMultiProvidersWithRegularProvidersError,\n  NoAnnotationError\n} from './reflective_errors';\nimport { ReflectiveKey } from './reflective_key';\n\ninterface NormalizedProvider extends TypeProvider, ValueProvider, ClassProvider, ExistingProvider,\n  FactoryProvider { }\n/**\n * `Dependency` is used by the framework to extend DI.\n * This is internal and should not be used directly.\n */\nexport class ReflectiveDependency {\n/**\n * @param {?} key\n * @param {?} optional\n * @param {?} visibility\n */\nconstructor(\npublic key: ReflectiveKey,\npublic optional: boolean,\npublic visibility: Self|SkipSelf) {}\n/**\n * @param {?} key\n * @return {?}\n */\nstatic fromKey(key: ReflectiveKey): ReflectiveDependency {\n    return new ReflectiveDependency(key, false, null);\n  }\n}\n\nfunction ReflectiveDependency_tsickle_Closure_declarations() {\n/** @type {?} */\nReflectiveDependency.prototype.key;\n/** @type {?} */\nReflectiveDependency.prototype.optional;\n/** @type {?} */\nReflectiveDependency.prototype.visibility;\n}\n\n\nconst /** @type {?} */ _EMPTY_LIST: any[] = [];\n\n/**\n * An internal resolved representation of a {@link Provider} used by the {@link Injector}.\n *\n * It is usually created automatically by `Injector.resolveAndCreate`.\n *\n * It can be created manually, as follows:\n *\n * ### Example ([live demo](http://plnkr.co/edit/RfEnhh8kUEI0G3qsnIeT?p%3Dpreview&p=preview))\n *\n * ```typescript\n * var resolvedProviders = Injector.resolve([{ provide: 'message', useValue: 'Hello' }]);\n * var injector = Injector.fromResolvedProviders(resolvedProviders);\n *\n * expect(injector.get('message')).toEqual('Hello');\n * ```\n *\n * @experimental\n */\nexport interface ResolvedReflectiveProvider {\n  /**\n   * A key, usually a `Type<any>`.\n   */\n  key: ReflectiveKey;\n\n  /**\n   * Factory function which can return an instance of an object represented by a key.\n   */\n  resolvedFactories: ResolvedReflectiveFactory[];\n\n  /**\n   * Indicates if the provider is a multi-provider or a regular provider.\n   */\n  multiProvider: boolean;\n}\nexport class ResolvedReflectiveProvider_ implements ResolvedReflectiveProvider {\n/**\n * @param {?} key\n * @param {?} resolvedFactories\n * @param {?} multiProvider\n */\nconstructor(\npublic key: ReflectiveKey,\npublic resolvedFactories: ResolvedReflectiveFactory[],\npublic multiProvider: boolean) { }\n/**\n * @return {?}\n */\nget resolvedFactory(): ResolvedReflectiveFactory { return this.resolvedFactories[0]; }\n}\n\nfunction ResolvedReflectiveProvider__tsickle_Closure_declarations() {\n/** @type {?} */\nResolvedReflectiveProvider_.prototype.key;\n/** @type {?} */\nResolvedReflectiveProvider_.prototype.resolvedFactories;\n/** @type {?} */\nResolvedReflectiveProvider_.prototype.multiProvider;\n}\n\n/**\n * An internal resolved representation of a factory function created by resolving {\\@link\n * Provider}.\n * \\@experimental\n */\nexport class ResolvedReflectiveFactory {\n/**\n * @param {?} factory\n * @param {?} dependencies\n */\nconstructor(\npublic factory: Function,\npublic dependencies: ReflectiveDependency[]) { }\n}\n\nfunction ResolvedReflectiveFactory_tsickle_Closure_declarations() {\n/**\n * Factory function which can return an instance of an object represented by a key.\n * @type {?}\n */\nResolvedReflectiveFactory.prototype.factory;\n/**\n * Arguments (dependencies) to the `factory` function.\n * @type {?}\n */\nResolvedReflectiveFactory.prototype.dependencies;\n}\n\n/**\n * Resolve a single provider.\n * @param {?} provider\n * @return {?}\n */\nfunction resolveReflectiveFactory(provider: NormalizedProvider): ResolvedReflectiveFactory {\n  let /** @type {?} */ factoryFn: Function;\n  let /** @type {?} */ resolvedDeps: ReflectiveDependency[];\n  if (provider.useClass) {\n    const /** @type {?} */ useClass = resolveForwardRef(provider.useClass);\n    factoryFn = reflector.factory(useClass);\n    resolvedDeps = _dependenciesFor(useClass);\n  } else if (provider.useExisting) {\n    factoryFn = (aliasInstance: any) => aliasInstance;\n    resolvedDeps = [ReflectiveDependency.fromKey(ReflectiveKey.get(provider.useExisting))];\n  } else if (provider.useFactory) {\n    factoryFn = provider.useFactory;\n    resolvedDeps = constructDependencies(provider.useFactory, provider.deps);\n  } else {\n    factoryFn = () => provider.useValue;\n    resolvedDeps = _EMPTY_LIST;\n  }\n  return new ResolvedReflectiveFactory(factoryFn, resolvedDeps);\n}\n/**\n * Converts the {\\@link Provider} into {\\@link ResolvedProvider}.\n * \n * {\\@link Injector} internally only uses {\\@link ResolvedProvider}, {\\@link Provider} contains\n * convenience provider syntax.\n * @param {?} provider\n * @return {?}\n */\nfunction resolveReflectiveProvider(provider: NormalizedProvider): ResolvedReflectiveProvider {\n  return new ResolvedReflectiveProvider_(\n    ReflectiveKey.get(provider.provide), [resolveReflectiveFactory(provider)], provider.multi);\n}\n/**\n * Resolve a list of Providers.\n * @param {?} providers\n * @return {?}\n */\nexport function resolveReflectiveProviders(providers: Provider[]): ResolvedReflectiveProvider[] {\n  const /** @type {?} */ normalized = _normalizeProviders(providers, []);\n  const /** @type {?} */ resolved = normalized.map(resolveReflectiveProvider);\n  const /** @type {?} */ resolvedProviderMap = mergeResolvedReflectiveProviders(resolved, new Map());\n  return Array.from(resolvedProviderMap.values());\n}\n/**\n * Merges a list of ResolvedProviders into a list where\n * each key is contained exactly once and multi providers\n * have been merged.\n * @param {?} providers\n * @param {?} normalizedProvidersMap\n * @return {?}\n */\nexport function mergeResolvedReflectiveProviders(\n  providers: ResolvedReflectiveProvider[],\n  normalizedProvidersMap: Map<number, ResolvedReflectiveProvider>):\n  Map<number, ResolvedReflectiveProvider> {\n  for (let /** @type {?} */ i = 0; i < providers.length; i++) {\n    const /** @type {?} */ provider = providers[i];\n    const /** @type {?} */ existing = normalizedProvidersMap.get(provider.key.id);\n    if (existing) {\n      if (provider.multiProvider !== existing.multiProvider) {\n        throw new MixingMultiProvidersWithRegularProvidersError(existing, provider);\n      }\n      if (provider.multiProvider) {\n        for (let /** @type {?} */ j = 0; j < provider.resolvedFactories.length; j++) {\n          existing.resolvedFactories.push(provider.resolvedFactories[j]);\n        }\n      } else {\n        normalizedProvidersMap.set(provider.key.id, provider);\n      }\n    } else {\n      let /** @type {?} */ resolvedProvider: ResolvedReflectiveProvider;\n      if (provider.multiProvider) {\n        resolvedProvider = new ResolvedReflectiveProvider_(\n          provider.key, provider.resolvedFactories.slice(), provider.multiProvider);\n      } else {\n        resolvedProvider = provider;\n      }\n      normalizedProvidersMap.set(provider.key.id, resolvedProvider);\n    }\n  }\n  return normalizedProvidersMap;\n}\n/**\n * @param {?} providers\n * @param {?} res\n * @return {?}\n */\nfunction _normalizeProviders(providers: Provider[], res: Provider[]): Provider[] {\n  providers.forEach(b => {\n    if (b instanceof Function) {\n      res.push({ provide: b, useClass: b });\n\n    } else if (b && typeof b == 'object' && ( /** @type {?} */((b as any))).provide !== undefined) {\n      res.push( /** @type {?} */((b as NormalizedProvider)));\n\n    } else if (b instanceof Array) {\n      _normalizeProviders(b, res);\n\n    } else {\n      throw new InvalidProviderError(b);\n    }\n  });\n\n  return res;\n}\n/**\n * @param {?} typeOrFunc\n * @param {?} dependencies\n * @return {?}\n */\nexport function constructDependencies(\n  typeOrFunc: any, dependencies: any[]): ReflectiveDependency[] {\n  if (!dependencies) {\n    return _dependenciesFor(typeOrFunc);\n  } else {\n    const /** @type {?} */ params: any[][] = dependencies.map(t => [t]);\n    return dependencies.map(t => _extractToken(typeOrFunc, t, params));\n  }\n}\n/**\n * @param {?} typeOrFunc\n * @return {?}\n */\nfunction _dependenciesFor(typeOrFunc: any): ReflectiveDependency[] {\n  const /** @type {?} */ params = reflector.parameters(typeOrFunc);\n\n  if (!params) return [];\n  if (params.some(p => p == null)) {\n    throw new NoAnnotationError(typeOrFunc, params);\n  }\n  return params.map(p => _extractToken(typeOrFunc, p, params));\n}\n/**\n * @param {?} typeOrFunc\n * @param {?} metadata\n * @param {?} params\n * @return {?}\n */\nfunction _extractToken(\n  typeOrFunc: any, metadata: any[] | any, params: any[][]): ReflectiveDependency {\n  let /** @type {?} */ token: any = null;\n  let /** @type {?} */ optional = false;\n\n  if (!Array.isArray(metadata)) {\n    if (metadata instanceof Inject) {\n      return _createDependency(metadata.token, optional, null);\n    } else {\n      return _createDependency(metadata, optional, null);\n    }\n  }\n\n  let /** @type {?} */ visibility: Self | SkipSelf = null;\n\n  for (let /** @type {?} */ i = 0; i < metadata.length; ++i) {\n    const /** @type {?} */ paramMetadata = metadata[i];\n\n    if (paramMetadata instanceof Function) {\n      token = paramMetadata;\n\n    } else if (paramMetadata instanceof Inject) {\n      token = paramMetadata.token;\n\n    } else if (paramMetadata instanceof Optional) {\n      optional = true;\n\n    } else if (paramMetadata instanceof Self || paramMetadata instanceof SkipSelf) {\n      visibility = paramMetadata;\n    }\n  }\n\n  token = resolveForwardRef(token);\n\n  if (token != null) {\n    return _createDependency(token, optional, visibility);\n  } else {\n    throw new NoAnnotationError(typeOrFunc, params);\n  }\n}\n/**\n * @param {?} token\n * @param {?} optional\n * @param {?} visibility\n * @return {?}\n */\nfunction _createDependency(\n  token: any, optional: boolean, visibility: Self | SkipSelf): ReflectiveDependency {\n  return new ReflectiveDependency(ReflectiveKey.get(token), optional, visibility);\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n// tslint:disable:variable-name class-name\n\n\nimport { Injector, THROW_IF_NOT_FOUND } from './injector';\nimport { Self, SkipSelf } from './metadata';\nimport { Provider } from './provider';\nimport {\n  AbstractProviderError, CyclicDependencyError,\n  InstantiationError, NoProviderError, OutOfBoundsError\n} from './reflective_errors';\nimport { ReflectiveKey } from './reflective_key';\nimport {\n  ReflectiveDependency, ResolvedReflectiveFactory,\n  ResolvedReflectiveProvider, resolveReflectiveProviders\n} from './reflective_provider';\n\n// Threshold for the dynamic version\nconst /** @type {?} */ UNDEFINED = new Object();\n/**\n * A ReflectiveDependency injection container used for instantiating objects and resolving\n * dependencies.\n * \n * An `Injector` is a replacement for a `new` operator, which can automatically resolve the\n * constructor dependencies.\n * \n * In typical use, application code asks for the dependencies in the constructor and they are\n * resolved by the `Injector`.\n * \n * ### Example ([live demo](http://plnkr.co/edit/jzjec0?p=preview))\n * \n * The following example creates an `Injector` configured to create `Engine` and `Car`.\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * var car = injector.get(Car);\n * expect(car instanceof Car).toBe(true);\n * expect(car.engine instanceof Engine).toBe(true);\n * ```\n * \n * Notice, we don't use the `new` operator because we explicitly want to have the `Injector`\n * resolve all of the object's dependencies automatically.\n * \n * \\@stable\n * @abstract\n */\nexport abstract class ReflectiveInjector implements Injector {\n/**\n * Turns an array of provider definitions into an array of resolved providers.\n * \n * A resolution is a process of flattening multiple nested arrays and converting individual\n * providers into an array of {\\@link ResolvedReflectiveProvider}s.\n * \n * ### Example ([live demo](http://plnkr.co/edit/AiXTHi?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var providers = ReflectiveInjector.resolve([Car, [[Engine]]]);\n * \n * expect(providers.length).toEqual(2);\n * \n * expect(providers[0] instanceof ResolvedReflectiveProvider).toBe(true);\n * expect(providers[0].key.displayName).toBe(\"Car\");\n * expect(providers[0].dependencies.length).toEqual(1);\n * expect(providers[0].factory).toBeDefined();\n * \n * expect(providers[1].key.displayName).toBe(\"Engine\");\n * });\n * ```\n * \n * See {\\@link ReflectiveInjector#fromResolvedProviders} for more info.\n * @param {?} providers\n * @return {?}\n */\nstatic resolve(providers: Provider[]): ResolvedReflectiveProvider[] {\n    return resolveReflectiveProviders(providers);\n  }\n/**\n * Resolves an array of providers and creates an injector from those providers.\n * \n * The passed-in providers can be an array of `Type`, {\\@link Provider},\n * or a recursive array of more providers.\n * \n * ### Example ([live demo](http://plnkr.co/edit/ePOccA?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Car, Engine]);\n * expect(injector.get(Car) instanceof Car).toBe(true);\n * ```\n * \n * This function is slower than the corresponding `fromResolvedProviders`\n * because it needs to resolve the passed-in providers first.\n * See {\\@link Injector#resolve} and {\\@link Injector#fromResolvedProviders}.\n * @param {?} providers\n * @param {?=} parent\n * @return {?}\n */\nstatic resolveAndCreate(providers: Provider[], parent: Injector = null): ReflectiveInjector {\n    const /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return ReflectiveInjector.fromResolvedProviders(ResolvedReflectiveProviders, parent);\n  }\n/**\n * Creates an injector from previously resolved providers.\n * \n * This API is the recommended way to construct injectors in performance-sensitive parts.\n * \n * ### Example ([live demo](http://plnkr.co/edit/KrSMci?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var providers = ReflectiveInjector.resolve([Car, Engine]);\n * var injector = ReflectiveInjector.fromResolvedProviders(providers);\n * expect(injector.get(Car) instanceof Car).toBe(true);\n * ```\n * \\@experimental\n * @param {?} providers\n * @param {?=} parent\n * @return {?}\n */\nstatic fromResolvedProviders(providers: ResolvedReflectiveProvider[], parent: Injector = null):\n    ReflectiveInjector {\n    return new ReflectiveInjector_(providers, parent);\n  }\n/**\n * Parent of this injector.\n * \n * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n * -->\n * \n * ### Example ([live demo](http://plnkr.co/edit/eosMGo?p=preview))\n * \n * ```typescript\n * var parent = ReflectiveInjector.resolveAndCreate([]);\n * var child = parent.resolveAndCreateChild([]);\n * expect(child.parent).toBe(parent);\n * ```\n * @abstract\n * @return {?}\n */\nparent() {}\n/**\n * Resolves an array of providers and creates a child injector from those providers.\n * \n * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n * -->\n * \n * The passed-in providers can be an array of `Type`, {\\@link Provider},\n * or a recursive array of more providers.\n * \n * ### Example ([live demo](http://plnkr.co/edit/opB3T4?p=preview))\n * \n * ```typescript\n * class ParentProvider {}\n * class ChildProvider {}\n * \n * var parent = ReflectiveInjector.resolveAndCreate([ParentProvider]);\n * var child = parent.resolveAndCreateChild([ChildProvider]);\n * \n * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n * ```\n * \n * This function is slower than the corresponding `createChildFromResolved`\n * because it needs to resolve the passed-in providers first.\n * See {\\@link Injector#resolve} and {\\@link Injector#createChildFromResolved}.\n * @abstract\n * @param {?} providers\n * @return {?}\n */\nresolveAndCreateChild(providers: Provider[]) {}\n/**\n * Creates a child injector from previously resolved providers.\n * \n * <!-- TODO: Add a link to the section of the user guide talking about hierarchical injection.\n * -->\n * \n * This API is the recommended way to construct injectors in performance-sensitive parts.\n * \n * ### Example ([live demo](http://plnkr.co/edit/VhyfjN?p=preview))\n * \n * ```typescript\n * class ParentProvider {}\n * class ChildProvider {}\n * \n * var parentProviders = ReflectiveInjector.resolve([ParentProvider]);\n * var childProviders = ReflectiveInjector.resolve([ChildProvider]);\n * \n * var parent = ReflectiveInjector.fromResolvedProviders(parentProviders);\n * var child = parent.createChildFromResolved(childProviders);\n * \n * expect(child.get(ParentProvider) instanceof ParentProvider).toBe(true);\n * expect(child.get(ChildProvider) instanceof ChildProvider).toBe(true);\n * expect(child.get(ParentProvider)).toBe(parent.get(ParentProvider));\n * ```\n * @abstract\n * @param {?} providers\n * @return {?}\n */\ncreateChildFromResolved(providers: ResolvedReflectiveProvider[]) {}\n/**\n * Resolves a provider and instantiates an object in the context of the injector.\n * \n * The created object does not get cached by the injector.\n * \n * ### Example ([live demo](http://plnkr.co/edit/yvVXoB?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n * \n * var car = injector.resolveAndInstantiate(Car);\n * expect(car.engine).toBe(injector.get(Engine));\n * expect(car).not.toBe(injector.resolveAndInstantiate(Car));\n * ```\n * @abstract\n * @param {?} provider\n * @return {?}\n */\nresolveAndInstantiate(provider: Provider) {}\n/**\n * Instantiates an object using a resolved provider in the context of the injector.\n * \n * The created object does not get cached by the injector.\n * \n * ### Example ([live demo](http://plnkr.co/edit/ptCImQ?p=preview))\n * \n * ```typescript\n * \\@Injectable() \n * class Engine {\n * }\n * \n * \\@Injectable() \n * class Car {\n *   constructor(public engine:Engine) {}\n * }\n * \n * var injector = ReflectiveInjector.resolveAndCreate([Engine]);\n * var carProvider = ReflectiveInjector.resolve([Car])[0];\n * var car = injector.instantiateResolved(carProvider);\n * expect(car.engine).toBe(injector.get(Engine));\n * expect(car).not.toBe(injector.instantiateResolved(carProvider));\n * ```\n * @abstract\n * @param {?} provider\n * @return {?}\n */\ninstantiateResolved(provider: ResolvedReflectiveProvider) {}\n/**\n * @abstract\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget(token: any, notFoundValue?: any) {}\n}\nexport class ReflectiveInjector_ implements ReflectiveInjector {\n/**\n * \\@internal\n */\n_constructionCounter = 0;\n/**\n * \\@internal\n */\npublic _providers: ResolvedReflectiveProvider[];\n/**\n * \\@internal\n */\npublic _parent: Injector;\n\n  keyIds: number[];\n  objs: any[];\n/**\n * Private\n * @param {?} _providers\n * @param {?=} _parent\n */\nconstructor(_providers: ResolvedReflectiveProvider[], _parent: Injector = null) {\n    this._providers = _providers;\n    this._parent = _parent;\n\n    const len = _providers.length;\n\n    this.keyIds = new Array(len);\n    this.objs = new Array(len);\n\n    for (let i = 0; i < len; i++) {\n      this.keyIds[i] = _providers[i].key.id;\n      this.objs[i] = UNDEFINED;\n    }\n  }\n/**\n * @param {?} token\n * @param {?=} notFoundValue\n * @return {?}\n */\nget(token: any, notFoundValue: any = THROW_IF_NOT_FOUND): any {\n    return this._getByKey(ReflectiveKey.get(token), null, notFoundValue);\n  }\n/**\n * @return {?}\n */\nget parent(): Injector { return this._parent; }\n/**\n * @param {?} providers\n * @return {?}\n */\nresolveAndCreateChild(providers: Provider[]): ReflectiveInjector {\n    const /** @type {?} */ ResolvedReflectiveProviders = ReflectiveInjector.resolve(providers);\n    return this.createChildFromResolved(ResolvedReflectiveProviders);\n  }\n/**\n * @param {?} providers\n * @return {?}\n */\ncreateChildFromResolved(providers: ResolvedReflectiveProvider[]): ReflectiveInjector {\n    const /** @type {?} */ inj = new ReflectiveInjector_(providers);\n    inj._parent = this;\n    return inj;\n  }\n/**\n * @param {?} provider\n * @return {?}\n */\nresolveAndInstantiate(provider: Provider): any {\n    return this.instantiateResolved(ReflectiveInjector.resolve([provider])[0]);\n  }\n/**\n * @param {?} provider\n * @return {?}\n */\ninstantiateResolved(provider: ResolvedReflectiveProvider): any {\n    return this._instantiateProvider(provider);\n  }\n/**\n * @param {?} index\n * @return {?}\n */\ngetProviderAtIndex(index: number): ResolvedReflectiveProvider {\n    if (index < 0 || index >= this._providers.length) {\n      throw new OutOfBoundsError(index);\n    }\n    return this._providers[index];\n  }\n/**\n * \\@internal\n * @param {?} provider\n * @return {?}\n */\n_new(provider: ResolvedReflectiveProvider): any {\n    if (this._constructionCounter++ > this._getMaxNumberOfObjects()) {\n      throw new CyclicDependencyError(this, provider.key);\n    }\n    return this._instantiateProvider(provider);\n  }\n/**\n * @return {?}\n */\nprivate _getMaxNumberOfObjects(): number { return this.objs.length; }\n/**\n * @param {?} provider\n * @return {?}\n */\nprivate _instantiateProvider(provider: ResolvedReflectiveProvider): any {\n    if (provider.multiProvider) {\n      const /** @type {?} */ res = new Array(provider.resolvedFactories.length);\n      for (let /** @type {?} */ i = 0; i < provider.resolvedFactories.length; ++i) {\n        res[i] = this._instantiate(provider, provider.resolvedFactories[i]);\n      }\n      return res;\n    } else {\n      return this._instantiate(provider, provider.resolvedFactories[0]);\n    }\n  }\n/**\n * @param {?} provider\n * @param {?} ResolvedReflectiveFactory\n * @return {?}\n */\nprivate _instantiate(\n    provider: ResolvedReflectiveProvider,\n    ResolvedReflectiveFactory: ResolvedReflectiveFactory): any {\n    const /** @type {?} */ factory = ResolvedReflectiveFactory.factory;\n\n    let /** @type {?} */ deps: any[];\n    try {\n      deps =\n        ResolvedReflectiveFactory.dependencies.map(dep => this._getByReflectiveDependency(dep));\n    } catch ( /** @type {?} */e) {\n      if (e instanceof AbstractProviderError || e instanceof InstantiationError) {\n        e.addKey(this, provider.key);\n      }\n      throw e;\n    }\n\n    let /** @type {?} */ obj: any;\n    try {\n      obj = factory(...deps);\n    } catch ( /** @type {?} */e) {\n      throw new InstantiationError(this, e, e.stack, provider.key);\n    }\n\n    return obj;\n  }\n/**\n * @param {?} dep\n * @return {?}\n */\nprivate _getByReflectiveDependency(dep: ReflectiveDependency): any {\n    return this._getByKey(dep.key, dep.visibility, dep.optional ? null : THROW_IF_NOT_FOUND);\n  }\n/**\n * @param {?} key\n * @param {?} visibility\n * @param {?} notFoundValue\n * @return {?}\n */\nprivate _getByKey(key: ReflectiveKey, visibility: Self | SkipSelf, notFoundValue: any): any {\n    if (key === INJECTOR_KEY) {\n      return this;\n    }\n\n    if (visibility instanceof Self) {\n      return this._getByKeySelf(key, notFoundValue);\n\n    } else {\n      return this._getByKeyDefault(key, notFoundValue, visibility);\n    }\n  }\n/**\n * @param {?} keyId\n * @return {?}\n */\nprivate _getObjByKeyId(keyId: number): any {\n    for (let /** @type {?} */ i = 0; i < this.keyIds.length; i++) {\n      if (this.keyIds[i] === keyId) {\n        if (this.objs[i] === UNDEFINED) {\n          this.objs[i] = this._new(this._providers[i]);\n        }\n\n        return this.objs[i];\n      }\n    }\n\n    return UNDEFINED;\n  }\n/**\n * \\@internal\n * @param {?} key\n * @param {?} notFoundValue\n * @return {?}\n */\n_throwOrNull(key: ReflectiveKey, notFoundValue: any): any {\n    if (notFoundValue !== THROW_IF_NOT_FOUND) {\n      return notFoundValue;\n    } else {\n      throw new NoProviderError(this, key);\n    }\n  }\n/**\n * \\@internal\n * @param {?} key\n * @param {?} notFoundValue\n * @return {?}\n */\n_getByKeySelf(key: ReflectiveKey, notFoundValue: any): any {\n    const /** @type {?} */ obj = this._getObjByKeyId(key.id);\n    return (obj !== UNDEFINED) ? obj : this._throwOrNull(key, notFoundValue);\n  }\n/**\n * \\@internal\n * @param {?} key\n * @param {?} notFoundValue\n * @param {?} visibility\n * @return {?}\n */\n_getByKeyDefault(key: ReflectiveKey, notFoundValue: any, visibility: Self | SkipSelf): any {\n    let /** @type {?} */ inj: Injector;\n\n    if (visibility instanceof SkipSelf) {\n      inj = this._parent;\n    } else {\n      inj = this;\n    }\n\n    while (inj instanceof ReflectiveInjector_) {\n      const /** @type {?} */ inj_ = /** @type {?} */(( <ReflectiveInjector_>inj));\n      const /** @type {?} */ obj = inj_._getObjByKeyId(key.id);\n      if (obj !== UNDEFINED) return obj;\n      inj = inj_._parent;\n    }\n    if (inj !== null) {\n      return inj.get(key.token, notFoundValue);\n    } else {\n      return this._throwOrNull(key, notFoundValue);\n    }\n  }\n/**\n * @return {?}\n */\nget displayName(): string {\n    const /** @type {?} */ providers =\n      _mapProviders(this, (b: ResolvedReflectiveProvider) => ' \"' + b.key.displayName + '\" ')\n        .join(', ');\n    return `ReflectiveInjector(providers: [${providers}])`;\n  }\n/**\n * @return {?}\n */\ntoString(): string { return this.displayName; }\n}\n\nfunction ReflectiveInjector__tsickle_Closure_declarations() {\n/**\n * \\@internal\n * @type {?}\n */\nReflectiveInjector_.prototype._constructionCounter;\n/**\n * \\@internal\n * @type {?}\n */\nReflectiveInjector_.prototype._providers;\n/**\n * \\@internal\n * @type {?}\n */\nReflectiveInjector_.prototype._parent;\n/** @type {?} */\nReflectiveInjector_.prototype.keyIds;\n/** @type {?} */\nReflectiveInjector_.prototype.objs;\n}\n\n\nconst /** @type {?} */ INJECTOR_KEY = ReflectiveKey.get(Injector);\n/**\n * @param {?} injector\n * @param {?} fn\n * @return {?}\n */\nfunction _mapProviders(injector: ReflectiveInjector_, fn: Function): any[] {\n  const /** @type {?} */ res: any[] = new Array(injector._providers.length);\n  for (let /** @type {?} */ i = 0; i < injector._providers.length; ++i) {\n    res[i] = fn(injector.getProviderAtIndex(i));\n  }\n  return res;\n}\n","import { PlatformAlreadyExistsError } from './platform_errors';\nimport { Injector } from '../di/injector';\nimport { InjectionToken } from '../di/injection_token';\nimport { Provider } from '../di/provider';\nimport { ReflectiveInjector } from '../di/reflective_injector';\nimport { ClassType } from '../type';\nimport { ComponentFactory } from '../component/factory';\n\nlet /** @type {?} */ _platform: PlatformRef;\n/**\n * @abstract\n */\nexport abstract class PlatformRef {\n/**\n * @abstract\n * @template C\n * @param {?} component\n * @return {?}\n */\nbootstrapComponent<C>(component: ClassType<C>) {}\n/**\n * @abstract\n * @return {?}\n */\ninjector() {}\n/**\n * @abstract\n * @param {?} callback\n * @return {?}\n */\nonDestroy(callback: () => void) {}\n/**\n * @abstract\n * @return {?}\n */\ndestroy() {}\n/**\n * @abstract\n * @return {?}\n */\ndestroyed() {}\n}\n/**\n * @return {?}\n */\nexport function getPlatform(): PlatformRef {\n  return _platform && !_platform.destroyed ? _platform : null;\n}\n/**\n * @param {?=} providers\n * @return {?}\n */\nexport function createPlatformFactory(providers: Provider[] = []):\n  (extraProviders?: Provider[]) => PlatformRef {\n  return (extraProviders: Provider[] = []) => {\n    if (getPlatform()) {\n      throw new PlatformAlreadyExistsError();\n    }\n\n    const /** @type {?} */ injector = ReflectiveInjector.resolveAndCreate(providers.concat(extraProviders));\n    _platform = injector.get(PlatformRef);\n    return _platform;\n  };\n}\n","import { ClassType } from '../type';\nimport { ComponentFactory } from './factory';\nimport { BaseError } from '../facade/error';\nimport { stringify } from '../facade/lang';\nexport class ComponentFactoryResolver {\nprivate _factories = new Map<any, ComponentFactory<any>>();\n/**\n * @param {?} factories\n * @param {?=} _parent\n */\nconstructor(factories: ComponentFactory<any>[],\nprivate _parent?: ComponentFactoryResolver) {\n    for (let i = 0; i < factories.length; i++) {\n      const factory = factories[i];\n      this._factories.set(factory.componentType, factory);\n    }\n  }\n/**\n * @template C\n * @param {?} componentType\n * @return {?}\n */\nresolveComponentFactory<C>(componentType: ClassType<C>): ComponentFactory<C> {\n    let /** @type {?} */ result = this._factories.get(componentType);\n    if (!result) {\n      if (!this._parent) {\n        throw new CouldNotResolveFactoryError(componentType);\n      }\n      result = this._parent.resolveComponentFactory(componentType);\n    }\n    return result;\n  }\n}\n\nfunction ComponentFactoryResolver_tsickle_Closure_declarations() {\n/** @type {?} */\nComponentFactoryResolver.prototype._factories;\n/** @type {?} */\nComponentFactoryResolver.prototype._parent;\n}\n\nexport class CouldNotResolveFactoryError extends BaseError {\n/**\n * @param {?} type\n */\nconstructor(type: ClassType<any>) {\n    super(`Could not resolve factory for \"${stringify(type)}! ` +\n      `Did you provide the component to the bootstrap function?`);\n  }\n}\n","import { ClassType } from '../type';\nimport { ComponentRef } from './reference';\nimport { Injector } from '../di/injector';\n/**\n * @abstract\n */\nexport abstract class ComponentFactory<C> {\n/**\n * @abstract\n * @return {?}\n */\nselector() {}\n/**\n * @abstract\n * @return {?}\n */\ncomponentType() {}\n/**\n * Creates a new component.\n * @abstract\n * @param {?} injector\n * @param {?=} rootSelectorOrNode\n * @return {?}\n */\ncreate(injector: Injector, rootSelectorOrNode?: string|any) {}\n}\n","import { ListWrapper } from '../facade/collection';\nimport { ComponentFactoryResolver } from '../component/factory_resolver';\nimport { ComponentRef } from '../component/reference';\nimport { ComponentFactory } from '../component/factory';\nimport { ClassType } from '../type';\nimport {\n  NotYetBootstrappedError,\n  AlreadyBootstrappedError\n} from './application_errors';\nimport { Component } from '../component/metadata';\nimport { ViewRef, InternalViewRef } from '../view/view_ref';\nimport { Injectable, Inject } from '../di/metadata';\nimport { Injector, THROW_IF_NOT_FOUND } from '../di/injector';\nimport {reflector} from '../reflection/reflection';\nimport { getPlatform } from './platform';\n/**\n * This is a reference of a Mojiito Application.\n * \n * @export\n * \\@class ApplicationRef\n */\nexport class ApplicationRef {\nprivate _rootComponents: ComponentRef<any>[] = [];\nprivate _rootComponentTypes: ClassType<any>[] = [];\nprivate _views: InternalViewRef[] = [];\n/**\n * @param {?} injector\n * @param {?} _componentFactoryResolver\n */\nconstructor(public injector: Injector,\nprivate _componentFactoryResolver: ComponentFactoryResolver) { }\n/**\n * @template C\n * @param {?} componentOrFactory\n * @return {?}\n */\nbootstrap<C>(componentOrFactory: ClassType<C> | ComponentFactory<C>): ComponentRef<C> {\n    let /** @type {?} */ componentFactory: ComponentFactory<C>;\n    if (componentOrFactory instanceof ComponentFactory) {\n      componentFactory = componentOrFactory;\n    } else {\n      componentFactory = this._componentFactoryResolver.resolveComponentFactory(componentOrFactory);\n    }\n    this._rootComponentTypes.push(componentFactory.componentType);\n    const /** @type {?} */ compRef = componentFactory.create(this.injector, componentFactory.selector);\n    compRef.onDestroy(() => { this._unloadComponent(compRef); });\n    this._loadComponent(compRef);\n    return compRef;\n  }\n/**\n * @param {?} viewRef\n * @return {?}\n */\nattachView(viewRef: ViewRef): void {\n    const /** @type {?} */ view = ( /** @type {?} */((viewRef as InternalViewRef)));\n    this._views.push(view);\n    view.attachToAppRef(this);\n  }\n/**\n * @param {?} viewRef\n * @return {?}\n */\ndetachView(viewRef: ViewRef): void {\n    const /** @type {?} */ view = ( /** @type {?} */((viewRef as InternalViewRef)));\n    ListWrapper.remove(this._views, view);\n    view.detachFromAppRef();\n  }\n/**\n * @param {?} componentRef\n * @return {?}\n */\nprivate _loadComponent(componentRef: ComponentRef<any>): void {\n    this.attachView(componentRef.hostView);\n    // this.tick();\n    this._rootComponents.push(componentRef);\n  }\n/**\n * @param {?} componentRef\n * @return {?}\n */\nprivate _unloadComponent(componentRef: ComponentRef<any>): void {\n    this.detachView(componentRef.hostView);\n    ListWrapper.remove(this._rootComponents, componentRef);\n  }\n/**\n * @return {?}\n */\nonDestroy() {\n    this._views.slice().forEach((view) => view.destroy());\n  }\nstatic decorators: DecoratorInvocation[] = [\n{ type: Injectable },\n];\n/**\n * @nocollapse\n */\nstatic ctorParameters: () => ({type: any, decorators?: DecoratorInvocation[]}|null)[] = () => [\n{type: Injector, },\n{type: ComponentFactoryResolver, },\n];\n}\n\nfunction ApplicationRef_tsickle_Closure_declarations() {\n/** @type {?} */\nApplicationRef.decorators;\n/**\n * @nocollapse\n * @type {?}\n */\nApplicationRef.ctorParameters;\n/** @type {?} */\nApplicationRef.prototype._rootComponents;\n/** @type {?} */\nApplicationRef.prototype._rootComponentTypes;\n/** @type {?} */\nApplicationRef.prototype._views;\n/** @type {?} */\nApplicationRef.prototype.injector;\n/** @type {?} */\nApplicationRef.prototype._componentFactoryResolver;\n}\n\n\ninterface DecoratorInvocation {\n  type: Function;\n  args?: any[];\n}\n","import { ClassType } from '../type';\nimport { Injector } from '../di/injector';\nimport { ElementRef } from '../view/element_ref';\nimport { ViewRef } from '../view/view_ref';\n/**\n * Represents an instance of a Component created via a ComponentFactory.\n * `ComponentRef` provides access to the Component Instance as well other objects related to this\n * Component Instance and allows you to destroy the Component Instance via the destroy method.\n * \n * @export\n * \\@class ComponentRef\n * @abstract\n */\nexport abstract class ComponentRef<C> {\n/**\n * Location of the component instance\n * @abstract\n * @return {?}\n */\nlocation() {}\n/**\n * The injector on which the component instance exists.\n * @abstract\n * @return {?}\n */\ninjector() {}\n/**\n * The instance of the Component.\n * @abstract\n * @return {?}\n */\ninstance() {}\n/**\n * @abstract\n * @return {?}\n */\nhostView() {}\n/**\n * The component type.\n * @abstract\n * @return {?}\n */\ncomponentType() {}\n/**\n * Destroys the component instance and all of the data structures associated with it.\n * @abstract\n * @return {?}\n */\ndestroy() {}\n/**\n * Allows to register a callback that will be called when the component is destroyed.\n * @abstract\n * @param {?} callback\n * @return {?}\n */\nonDestroy(callback: Function) {}\n}\n","import { ViewRef } from './view_ref';\nimport { ElementRef } from './element_ref';\nimport { Injector } from '../di/injector';\nimport { ComponentFactory } from '../component/factory';\nimport { ComponentRef } from '../component/reference';\n/**\n * @abstract\n */\nexport abstract class ViewContainerRef {\n/**\n * @abstract\n * @return {?}\n */\nanchorElement() {}\n/**\n * @abstract\n * @return {?}\n */\ninjector() {}\n/**\n * @abstract\n * @return {?}\n */\nparentInjector() {}\n/**\n * Destroys all Views in this container.\n * @abstract\n * @return {?}\n */\nclear() {}\n/**\n * Returns the ViewRef for the View located in this container at the specified index.\n * @abstract\n * @param {?} index\n * @return {?}\n */\nget(index: number) {}\n/**\n * Returns the number of Views currently attached to this container.\n * @abstract\n * @return {?}\n */\nlength() {}\n/**\n * Instantiates an Embedded View based on the TemplateRef `templateRef`} and inserts it\n * into this container at the specified `index`.\n * \n * If `index` is not specified, the new View will be inserted as the last View in the container.\n * \n * Returns the ViewRef for the newly created View.\n * @abstract\n * @template C\n * @param {?} templateRef\n * @param {?=} context\n * @param {?=} index\n * @return {?}\n */\ncreateEmbeddedView<C>(templateRef: any, context?: C, index?: number) {}\n/**\n * Instantiates a single Component and inserts its Host View into this container at the\n * specified `index`.\n * \n * The component is instantiated using its ComponentFactory which can be\n * obtained via ComponentFactoryResolver#resolveComponentFactory}.\n * \n * If `index` is not specified, the new View will be inserted as the last View in the container.\n * \n * You can optionally specify the Injector that will be used as parent for the Component.\n * \n * Returns the ComponentRef of the Host View created for the newly instantiated Component.\n * @abstract\n * @template C\n * @param {?} componentFactory\n * @param {?=} index\n * @param {?=} injector\n * @param {?=} projectableNodes\n * @return {?}\n */\ncreateComponent<C>(\n      componentFactory: ComponentFactory<C>, index?: number, injector?: Injector,\n      projectableNodes?: any[][]) {}\n/**\n * Returns the index of the View, specified via ViewRef, within the current container or\n * `-1` if this container doesn't contain the View.\n * @abstract\n * @param {?} viewRef\n * @return {?}\n */\nindexOf(viewRef: ViewRef) {}\n/**\n * Destroys a View attached to this container at the specified `index`.\n * \n * If `index` is not specified, the last View in the container will be removed.\n * @abstract\n * @param {?=} index\n * @return {?}\n */\nremove(index?: number) {}\n/**\n * Use along with #nsert} to move a View within the current container.\n * \n * If the `index` param is omitted, the last ViewRef is detached.\n * @abstract\n * @param {?=} index\n * @return {?}\n */\ndetach(index?: number) {}\n}\n","import { stringify } from '../facade/lang';\nimport { Renderer } from '../render';\nimport { Injector } from '../di/injector';\nimport { resolveReflectiveProviders, ReflectiveDependency } from '../di/reflective_provider';\nimport { ReflectiveKey } from '../di/reflective_key';\nimport { Provider } from '../di/provider';\nimport { ElementRef } from './element_ref';\nimport { ViewContainerRef } from './view_container_ref';\nimport { createViewContainerData, createInjector } from './refs';\nimport {\n  ViewData, ProviderData, NodeDef, NodeFlags, DepDef, DepFlags,\n  asProviderData\n} from './types';\n\nconst /** @type {?} */ NOT_CREATED = new Object();\n\n// tslint:disable:variable-name\nconst /** @type {?} */ _tokenKeyCache = new Map<any, string>();\nconst /** @type {?} */ RendererTokenKey = tokenKey(Renderer);\nconst /** @type {?} */ ElementRefTokenKey = tokenKey(ElementRef);\nconst /** @type {?} */ ViewContainerRefTokenKey = tokenKey(ViewContainerRef);\n// const ChangeDetectorRefTokenKey = tokenKey(ChangeDetectorRef);\nconst /** @type {?} */ InjectorRefTokenKey = tokenKey(Injector);\n/**\n * @param {?} token\n * @return {?}\n */\nexport function tokenKey(token: any): string {\n  let /** @type {?} */ key = _tokenKeyCache.get(token);\n  if (!key) {\n    key = stringifyToken(token); // + '_' + _tokenKeyCache.size;\n    _tokenKeyCache.set(token, key);\n  }\n  return key;\n}\n/**\n * @param {?} token\n * @return {?}\n */\nfunction stringifyToken(token: any): string {\n  if (token instanceof ReflectiveDependency) {\n    return token.key.displayName;\n  }\n  if (token instanceof ReflectiveKey) {\n    return token.displayName;\n  }\n  return stringify(token);\n}\n/**\n * @param {?} view\n * @param {?} depDef\n * @param {?} allowPrivateServices\n * @param {?=} notFoundValue\n * @return {?}\n */\nexport function resolveDep(view: ViewData, depDef: DepDef, allowPrivateServices: boolean,\n  notFoundValue = Injector.THROW_IF_NOT_FOUND): any {\n\n  if (depDef.flags & DepFlags.Value) {\n    return depDef.token;\n  }\n  const /** @type {?} */ startView = view;\n  if (depDef.flags & DepFlags.Optional) {\n    notFoundValue = null;\n  }\n\n  const /** @type {?} */ tokenKey = depDef.tokenKey;\n\n  if (depDef.flags & DepFlags.SkipSelf) {\n    allowPrivateServices = false;\n    view = view.parent;\n  }\n\n  while (view) {\n    let /** @type {?} */ def = view.def;\n    if (def) {\n      switch (tokenKey) {\n        case RendererTokenKey:\n          return view.renderer;\n        case ElementRefTokenKey:\n          return new ElementRef(view.renderElement);\n        case ViewContainerRefTokenKey:\n          return view.viewContainer || view.viewContainerParent;\n        // case ChangeDetectorRefTokenKey: {\n        //   let cdView = findCompView(view, elDef, allowPrivateServices);\n        //   return createChangeDetectorRef(cdView);\n        // }\n        case InjectorRefTokenKey:\n          return createInjector(view);\n        default:\n          const /** @type {?} */ providerDef =\n            (allowPrivateServices ? def.allProviders : def.publicProviders)[tokenKey];\n          if (providerDef) {\n            const /** @type {?} */ providerData = asProviderData(view, providerDef.index);\n            if (providerData.instance === NOT_CREATED) {\n              providerData.instance = _createProviderInstance(view, providerDef);\n            }\n            return providerData.instance;\n          }\n      }\n    }\n    view = view.parent;\n  }\n  return startView.root.injector.get(depDef.token, notFoundValue);\n}\n/**\n * @param {?} view\n * @param {?} def\n * @return {?}\n */\nfunction _createProviderInstance(view: ViewData, def: NodeDef): any {\n  // private services can see other private services\n\n  const /** @type {?} */ allowPrivateServices = (def.flags & NodeFlags.PrivateProvider) > 0;\n  const /** @type {?} */ providerDef = def.provider;\n  let /** @type {?} */ deps: any[] = [];\n  if (providerDef.deps) {\n    deps = providerDef.deps.map(d => resolveDep(view, d, allowPrivateServices));\n  }\n  return providerDef.factory(...deps);\n}\n/**\n * @param {?} view\n * @param {?} def\n * @return {?}\n */\nexport function createProviderInstance(view: ViewData, def: NodeDef): any {\n  return def.flags & NodeFlags.LazyProvider ? NOT_CREATED : _createProviderInstance(view, def);\n}\n/**\n * @param {?} view\n * @param {?} index\n * @param {?} lifecycles\n * @return {?}\n */\nfunction callProviderLifecycles(view: ViewData, index: number, lifecycles: NodeFlags) {\n  const /** @type {?} */ provider = asProviderData(view, index).instance;\n  if (provider === NOT_CREATED) {\n    return;\n  }\n  if (lifecycles & NodeFlags.OnDestroy) {\n    provider.ngOnDestroy();\n  }\n}\n","import { Injector } from '../di/injector';\nimport { ViewDefinition, ViewDefinitionFactory, ViewData } from './types';\nimport { createInjector } from './refs';\n\nconst /** @type {?} */ VIEW_DEFINITION_CACHE = new WeakMap<any, ViewDefinition>();\n/**\n * @param {?} factory\n * @return {?}\n */\nexport function resolveViewDefinition(factory: ViewDefinitionFactory): ViewDefinition {\n  let /** @type {?} */ value: ViewDefinition = VIEW_DEFINITION_CACHE.get(factory);\n  if (!value) {\n    value = factory();\n    VIEW_DEFINITION_CACHE.set(factory, value);\n  }\n  return value;\n}\n","import { Renderer, RendererFactory, RendererType } from '../render';\nimport { ComponentRef } from '../component/reference';\nimport { Injector } from '../di/injector';\nimport { Provider } from '../di/provider';\nimport { resolveReflectiveProviders } from '../di/reflective_provider';\nimport { ClassType } from '../type';\nimport { ViewContainerRef } from './view_container_ref';\nimport {\n  ViewData, ViewState, RootData, ViewDefinition, NodeFlags, ProviderData,\n  NodeData\n} from './types';\nimport { tokenKey, createProviderInstance } from './provider';\nimport { createViewContainerData } from './refs';\n/**\n * @param {?} def\n * @param {?} injector\n * @param {?} rootSelectorOrNode\n * @param {?=} context\n * @return {?}\n */\nexport function createRootView(def: ViewDefinition, injector: Injector,\n  rootSelectorOrNode: string | any, context?: any): ViewData {\n  const /** @type {?} */ rendererFactory: RendererFactory = injector.get(RendererFactory);\n  const /** @type {?} */ root = createRootData(injector, rendererFactory, rootSelectorOrNode);\n  const /** @type {?} */ view = createView(root, null, root.element, def);\n  view.renderer.parse(view);\n  return view;\n}\n/**\n * @param {?} root\n * @param {?} parent\n * @param {?} renderElement\n * @param {?} def\n * @return {?}\n */\nexport function createView(root: RootData,\n  parent: ViewData, renderElement: any, def: ViewDefinition): ViewData {\n  const /** @type {?} */ nodes: NodeData[] = new Array(def.nodes.length);\n  const /** @type {?} */ view: ViewData = {\n    def,\n    renderElement,\n    root,\n    renderer: createRenderer(renderElement, def, parent, root),\n    nodes,\n    parent,\n    viewContainerParent: undefined,\n    viewContainer: undefined,\n    context: undefined,\n    component: undefined,\n    state: ViewState.FirstCheck | ViewState.ChecksEnabled,\n    disposables: undefined,\n  };\n  if (def.nodeFlags & NodeFlags.TypeComponent) {\n    view.viewContainer = createViewContainerData(view);\n  }\n  createViewNodes(view);\n  return view;\n}\n/**\n * @param {?} view\n * @param {?} component\n * @param {?} context\n * @return {?}\n */\nexport function initView(view: ViewData, component: any, context: any) {\n  view.component = component;\n  view.context = context;\n}\n/**\n * @param {?} view\n * @return {?}\n */\nexport function destroyView(view: ViewData) {\n  if (view.state & ViewState.Destroyed) {\n    return;\n  }\n  // execEmbeddedViewsAction(view, ViewAction.Destroy);\n  // execComponentViewsAction(view, ViewAction.Destroy);\n  // callLifecycleHooksChildrenFirst(view, NodeFlags.OnDestroy);\n  if (view.disposables) {\n    for (let /** @type {?} */ i = 0; i < view.disposables.length; i++) {\n      view.disposables[i]();\n    }\n  }\n  destroyViewNodes(view);\n  view.renderer.destroy();\n  view.state |= ViewState.Destroyed;\n}\n/**\n * @param {?} view\n * @return {?}\n */\nfunction createViewNodes(view: ViewData) {\n  const /** @type {?} */ def = view.def;\n  const /** @type {?} */ nodes = view.nodes;\n  let /** @type {?} */ nodeData: any;\n  for (let /** @type {?} */ i = 0; i < def.nodes.length; i++) {\n    const /** @type {?} */ nodeDef = def.nodes[i];\n    switch (nodeDef.flags & NodeFlags.Types) {\n      case NodeFlags.TypeProvider: {\n        const /** @type {?} */ instance = createProviderInstance(view, nodeDef);\n        nodeData = /** @type {?} */(( <ProviderData>{ instance }));\n        break;\n      }\n      case NodeFlags.TypeComponent: {\n        const /** @type {?} */ instance = createProviderInstance(view, nodeDef);\n        nodeData = /** @type {?} */(( <ProviderData>{ instance }));\n\n        initView(view, instance, instance);\n        break;\n      }\n    }\n    nodes[i] = nodeData;\n  }\n}\n/**\n * @param {?} view\n * @return {?}\n */\nfunction destroyViewNodes(view: ViewData) {\n  view.renderer.destroyNode(view.renderElement);\n}\n/**\n * @param {?} injector\n * @param {?} rendererFactory\n * @param {?} rootSelectorOrNode\n * @return {?}\n */\nfunction createRootData(\n  injector: Injector, rendererFactory: RendererFactory, rootSelectorOrNode: any): RootData {\n  const /** @type {?} */ renderer = rendererFactory.createRenderer(null, null);\n  let /** @type {?} */ element = rootSelectorOrNode;\n  if (typeof rootSelectorOrNode === 'string') {\n    element = renderer.selectRootElement(rootSelectorOrNode);\n  }\n  return {\n    injector,\n    selectorOrNode: rootSelectorOrNode,\n    element,\n    rendererFactory,\n    renderer\n  };\n}\n/**\n * @param {?} publicProviders\n * @param {?} componentProvider\n * @return {?}\n */\nfunction viewDef(publicProviders: Provider[], componentProvider: any): ViewDefinition {\n  var /** @type {?} */ viewDef: any = {};\n  // resolve public providers\n  const /** @type {?} */ publicProv: any = Object.create(null);\n  if (publicProviders) {\n    resolveReflectiveProviders(publicProviders).forEach(p => {\n      const /** @type {?} */ resolvedFactory = p.resolvedFactories[0];\n      publicProv[tokenKey(p.key)] = {\n        factory: resolvedFactory.factory,\n        dependencies: resolvedFactory.dependencies,\n        multi: p.multiProvider\n      };\n    });\n  }\n  viewDef.publicProviders = publicProv;\n\n  // combine to all providers\n  const /** @type {?} */ allProviders = Object.create(publicProv);\n  viewDef.allProviders = allProviders;\n\n  // resolve component provider\n  if (componentProvider) {\n    const /** @type {?} */ resolvedComp = resolveReflectiveProviders([componentProvider])[0];\n    const /** @type {?} */ resolvedCompFactory = resolvedComp.resolvedFactories[0];\n    viewDef.componentProvider = {\n      factory: resolvedCompFactory.factory,\n      dependencies: resolvedCompFactory.dependencies,\n      multi: false,\n    };\n    allProviders[tokenKey(resolvedComp.key)] = viewDef.componentProvider;\n  }\n\n  return viewDef;\n}\n/**\n * @param {?} publicProviders\n * @param {?} componentProvider\n * @return {?}\n */\nexport function createViewDefinitionFactory(publicProviders: Provider[], componentProvider: any) {\n  return () => {\n    return viewDef(publicProviders, componentProvider);\n  };\n}\n/**\n * @param {?} hostElement\n * @param {?} viewDef\n * @param {?} parentView\n * @param {?} root\n * @return {?}\n */\nfunction createRenderer(hostElement: any, viewDef: ViewDefinition,\n      parentView: ViewData, root: RootData) {\n    let /** @type {?} */ rendererType: RendererType = viewDef.componentRendererType;\n    let /** @type {?} */ view = parentView;\n    while (view && !rendererType) {\n      rendererType = view.def.componentRendererType;\n      view = view.parent;\n    }\n\n    if (!rendererType) {\n      return root.renderer;\n    } else {\n      return root.rendererFactory.createRenderer(hostElement, rendererType);\n    }\n}\n","import { ViewData } from './types';\n/**\n * @param {?} parentView\n * @param {?} viewIndex\n * @param {?} view\n * @return {?}\n */\nexport function attachEmbeddedView(parentView: ViewData, viewIndex: number, view: ViewData) {\n  let /** @type {?} */ embeddedViews = parentView.viewContainer._embeddedViews;\n  if (viewIndex == null) {\n    viewIndex = embeddedViews.length;\n  }\n  view.viewContainerParent = parentView;\n  addToArray(embeddedViews, viewIndex, view);\n}\n/**\n * @param {?} parent\n * @param {?} viewIndex\n * @return {?}\n */\nexport function detachEmbeddedView(parent: ViewData, viewIndex: number): ViewData {\n  const /** @type {?} */ embeddedViews = parent.viewContainer._embeddedViews;\n  if (viewIndex == null || viewIndex >= embeddedViews.length) {\n    viewIndex = embeddedViews.length - 1;\n  }\n  if (viewIndex < 0) {\n    return null;\n  }\n  const /** @type {?} */ view = embeddedViews[viewIndex];\n  view.viewContainerParent = undefined;\n  removeFromArray(embeddedViews, viewIndex);\n  return view;\n}\n/**\n * @param {?} arr\n * @param {?} index\n * @param {?} value\n * @return {?}\n */\nfunction addToArray(arr: any[], index: number, value: any) {\n  // perf: array.push is faster than array.splice!\n  if (index >= arr.length) {\n    arr.push(value);\n  } else {\n    arr.splice(index, 0, value);\n  }\n}\n/**\n * @param {?} arr\n * @param {?} index\n * @return {?}\n */\nfunction removeFromArray(arr: any[], index: number) {\n  // perf: array.pop is faster than array.splice!\n  if (index >= arr.length - 1) {\n    arr.pop();\n  } else {\n    arr.splice(index, 1);\n  }\n}\n","\n/**\n * Returns the class name of a type.\n * \n * @export\n * @template T\n * @param {?} klass\n * @return {?}\n */\nexport function getClassName<T>(klass: Function) {\n  return ( /** @type {?} */((klass as any))).name ? ( /** @type {?} */((klass as any))).name :\n    /^function\\s+([\\w\\$]+)\\s*\\(/.exec(this.toString())[1];\n}\n/**\n * Tries to stringify a token. A token can be any type.\n * \n * @export\n * @param {?} token\n * @return {?}\n */\nexport function stringify(token: any): string {\n  if (typeof token === 'string') {\n    return token;\n  }\n\n  if (token === undefined || token === null) {\n    return '' + token;\n  }\n  if (token.name) {\n    return token.name;\n  }\n  if (token.overriddenName) {\n    return token.overriddenName;\n  }\n  if (typeof token === 'function') {\n      return getClassName(token);\n  }\n  if (token instanceof HTMLElement) {\n    let /** @type {?} */ parts = token.toString().match(/\\w+/g);\n    if (parts && parts.length) {\n      return parts[parts.length - 1];\n    }\n  }\n\n  var /** @type {?} */ res = token.toString();\n  var /** @type {?} */ newLineIndex = res.indexOf('\\n');\n  return (newLineIndex === -1) ? res : res.substring(0, newLineIndex);\n}\n\nexport interface BrowserNodeGlobal {\n  Object: typeof Object;\n  Array: typeof Array;\n  Map: typeof Map;\n  Set: typeof Set;\n  Date: DateConstructor;\n  RegExp: RegExpConstructor;\n  JSON: typeof JSON;\n  Math: any;  // typeof Math;\n  assert(condition: any): void;\n  Reflect: any;\n  setTimeout: Function;\n  clearTimeout: Function;\n  setInterval: Function;\n  clearInterval: Function;\n  encodeURI: Function;\n}\n\ndeclare var WorkerGlobalScope: any;\ndeclare var global: any;\nlet /** @type {?} */ globalScope: BrowserNodeGlobal;\nif (typeof window === 'undefined') {\n  if (typeof WorkerGlobalScope !== 'undefined' && self instanceof WorkerGlobalScope) {\n    // TODO: Replace any with WorkerGlobalScope from lib.webworker.d.ts #3492\n    globalScope = /** @type {?} */(( <any>self));\n  } else {\n    globalScope = /** @type {?} */(( <any>global));\n  }\n} else {\n  globalScope = /** @type {?} */(( <any>window));\n}\nexport {globalScope as global};\n/**\n * @param {?} obj\n * @return {?}\n */\nexport function isPresent(obj: any): boolean {\n  return obj != null;\n}\n/**\n * @param {?} obj\n * @return {?}\n */\nexport function isBlank(obj: any): boolean {\n  return obj == null;\n}\nexport class NumberWrapper {\n/**\n * @param {?} text\n * @return {?}\n */\nstatic parseIntAutoRadix(text: string): number {\n    const /** @type {?} */ result: number = parseInt(text);\n    if (isNaN(result)) {\n      throw new Error('Invalid integer literal when parsing ' + text);\n    }\n    return result;\n  }\n/**\n * @param {?} value\n * @return {?}\n */\nstatic isNumeric(value: any): boolean { return !isNaN(value - parseFloat(value)); }\n}\n","\n/**\n * @license \n * Copyright Google Inc. All Rights Reserved.\n * \n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\nexport class StringMapWrapper {\n/**\n * @template V\n * @param {?} m1\n * @param {?} m2\n * @return {?}\n */\nstatic merge<V>(m1: {[key: string]: V}, m2: {[key: string]: V}): {[key: string]: V} {\n    const /** @type {?} */ m: {[key: string]: V} = {};\n\n    for (const /** @type {?} */ k of Object.keys(m1)) {\n      m[k] = m1[k];\n    }\n\n    for (const /** @type {?} */ k of Object.keys(m2)) {\n      m[k] = m2[k];\n    }\n\n    return m;\n  }\n/**\n * @template V\n * @param {?} m1\n * @param {?} m2\n * @return {?}\n */\nstatic equals<V>(m1: {[key: string]: V}, m2: {[key: string]: V}): boolean {\n    const /** @type {?} */ k1 = Object.keys(m1);\n    const /** @type {?} */ k2 = Object.keys(m2);\n\n    if (k1.length != k2.length) {\n      return false;\n    }\n\n    for (let /** @type {?} */ i = 0; i < k1.length; i++) {\n      const /** @type {?} */ key = k1[i];\n      if (m1[key] !== m2[key]) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n}\nexport class ListWrapper {\n/**\n * @template T\n * @param {?} arr\n * @param {?} condition\n * @return {?}\n */\nstatic findLast<T>(arr: T[], condition: (value: T) => boolean): T {\n    for (let /** @type {?} */ i = arr.length - 1; i >= 0; i--) {\n      if (condition(arr[i])) {\n        return arr[i];\n      }\n    }\n    return null;\n  }\n/**\n * @template T\n * @param {?} list\n * @param {?} items\n * @return {?}\n */\nstatic removeAll<T>(list: T[], items: T[]) {\n    for (let /** @type {?} */ i = 0; i < items.length; ++i) {\n      const /** @type {?} */ index = list.indexOf(items[i]);\n      if (index > -1) {\n        list.splice(index, 1);\n      }\n    }\n  }\n/**\n * @template T\n * @param {?} list\n * @param {?} el\n * @return {?}\n */\nstatic remove<T>(list: T[], el: T): boolean {\n    const /** @type {?} */ index = list.indexOf(el);\n    if (index > -1) {\n      list.splice(index, 1);\n      return true;\n    }\n    return false;\n  }\n/**\n * @param {?} a\n * @param {?} b\n * @return {?}\n */\nstatic equals(a: any[], b: any[]): boolean {\n    if (a.length != b.length) return false;\n    for (let /** @type {?} */ i = 0; i < a.length; ++i) {\n      if (a[i] !== b[i]) return false;\n    }\n    return true;\n  }\n/**\n * @template T\n * @param {?} list\n * @return {?}\n */\nstatic flatten<T>(list: Array<T | T[]>): T[] {\n    return list.reduce((flat: any[], item: T | T[]): T[] => {\n      const /** @type {?} */ flatItem = Array.isArray(item) ? ListWrapper.flatten(item) : item;\n      return ( /** @type {?} */((<T[]>flat))).concat(flatItem);\n    }, []);\n  }\n/**\n * @template T\n * @param {?} list\n * @param {?} callback\n * @return {?}\n */\nstatic forEach<T>(list: ArrayLike<T>, callback: (item: T, index: number) => void): void {\n    for (let /** @type {?} */ i = 0, /** @type {?} */ max = list.length; i < max; i++) {\n      callback.call(callback, list[i], i);\n    }\n  }\n}\n","/**\n * @license\n * Copyright Google Inc. All Rights Reserved.\n *\n * Use of this source code is governed by an MIT-style license that can be\n * found in the LICENSE file at https://angular.io/license\n */\n\n\nimport { global, stringify } from '../facade/lang';\nimport { ClassType } from '../type';\n\nlet /** @type {?} */ _nextClassId = 0;\nconst /** @type {?} */ Reflect = global.Reflect;\n\n\nexport interface TypeDecorator {\n  <T extends ClassType<any>>(type: T): T;\n  (target: Object, propertyKey?: string | symbol, parameterIndex?: number): void;\n  annotations: any[];\n  Class(obj: ClassType<any>): ClassType<any>;\n}\n/**\n * @param {?} annotation\n * @return {?}\n */\nfunction extractAnnotation(annotation: any): any {\n  if (typeof annotation === 'function' && annotation.hasOwnProperty('annotation')) {\n    // it is a decorator, extract annotation\n    annotation = annotation.annotation;\n  }\n  return annotation;\n}\n/**\n * @param {?} fnOrArray\n * @param {?} key\n * @return {?}\n */\nfunction applyParams(fnOrArray: (Function | any[]), key: string): Function {\n  if (fnOrArray === Object || fnOrArray === String || fnOrArray === Function ||\n    fnOrArray === Number || fnOrArray === Array) {\n    throw new Error(`Can not use native ${stringify(fnOrArray)} as constructor`);\n  }\n\n  if (typeof fnOrArray === 'function') {\n    return fnOrArray;\n  }\n\n  if (Array.isArray(fnOrArray)) {\n    const /** @type {?} */ annotations: any[] = fnOrArray;\n    const /** @type {?} */ annoLength = annotations.length - 1;\n    const /** @type {?} */ fn: Function = fnOrArray[annoLength];\n    if (typeof fn !== 'function') {\n      throw new Error(`Last position of Class method array must be ` +\n        `Function in key ${key} was '${stringify(fn)}'`);\n    }\n    if (annoLength != fn.length) {\n      throw new Error(`Number of annotations (${annoLength}) does not match ` +\n        `number of arguments (${fn.length}) in the function: ${stringify(fn)}`);\n    }\n    const /** @type {?} */ paramsAnnotations: any[][] = [];\n    for (let /** @type {?} */ i = 0, /** @type {?} */ ii = annotations.length - 1; i < ii; i++) {\n      const /** @type {?} */ paramAnnotations: any[] = [];\n      paramsAnnotations.push(paramAnnotations);\n      const /** @type {?} */ annotation = annotations[i];\n      if (Array.isArray(annotation)) {\n        for (let /** @type {?} */ j = 0; j < annotation.length; j++) {\n          paramAnnotations.push(extractAnnotation(annotation[j]));\n        }\n      } else if (typeof annotation === 'function') {\n        paramAnnotations.push(extractAnnotation(annotation));\n      } else {\n        paramAnnotations.push(annotation);\n      }\n    }\n    Reflect.defineMetadata('parameters', paramsAnnotations, fn);\n    return fn;\n  }\n\n  throw new Error(`Only Function or Array is supported in Class ` +\n    `definition for key '${key}' is '${stringify(fnOrArray)}'`);\n}\n/**\n * @param {?} name\n * @param {?} props\n * @param {?=} parentClass\n * @param {?=} chainFn\n * @return {?}\n */\nexport function makeDecorator(\n  name: string, props: { [name: string]: any }, parentClass?: any,\n  chainFn: (fn: Function) => void = null): (...args: any[]) => (cls: any) => any {\n  const /** @type {?} */ metaCtor = makeMetadataCtor([props]);\n/**\n * @param {?} objOrType\n * @return {?}\n */\nfunction DecoratorFactory(objOrType: any): (cls: any) => any {\n    if (!(Reflect && Reflect.getOwnMetadata)) {\n      throw 'reflect-metadata shim is required when using class decorators';\n    }\n\n    if (this instanceof DecoratorFactory) {\n      metaCtor.call(this, objOrType);\n      return this;\n    }\n\n    const /** @type {?} */ annotationInstance = new ( /** @type {?} */((<any>DecoratorFactory)))(objOrType);\n    const /** @type {?} */ chainAnnotation =\n      typeof this === 'function' && Array.isArray(this.annotations) ? this.annotations : [];\n    chainAnnotation.push(annotationInstance);\n    // tslint:disable-next-line:variable-name\n    const /** @type {?} */ TypeDecorator: TypeDecorator = /** @type {?} */((\n      <TypeDecorator>function TypeDecorator(cls: ClassType<any>) {\n        const /** @type {?} */ annotations = Reflect.getOwnMetadata('annotations', cls) || [];\n        annotations.push(annotationInstance);\n        Reflect.defineMetadata('annotations', annotations, cls);\n        return cls;\n      }));\n    TypeDecorator.annotations = chainAnnotation;\n    // TypeDecorator.Class = Class;\n    if (chainFn) chainFn(TypeDecorator);\n    return TypeDecorator;\n  }\n\n  if (parentClass) {\n    DecoratorFactory.prototype = Object.create(parentClass.prototype);\n  }\n\n  DecoratorFactory.prototype.toString = () => `@${name}`;\n  ( /** @type {?} */((<any>DecoratorFactory))).annotationCls = DecoratorFactory;\n  return DecoratorFactory;\n}\n/**\n * @param {?} props\n * @return {?}\n */\nfunction makeMetadataCtor(props: ([string, any] | { [key: string]: any })[]): any {\n  return function ctor(...args: any[]) {\n    props.forEach((prop, i) => {\n      const /** @type {?} */ argVal = args[i];\n      if (Array.isArray(prop)) {\n        // plain parameter\n        this[prop[0]] = argVal === undefined ? prop[1] : argVal;\n      } else {\n        for (const /** @type {?} */ propName in prop) {\n          this[propName] =\n            argVal && argVal.hasOwnProperty(propName) ? argVal[propName] : prop[propName];\n        }\n      }\n    });\n  };\n}\n/**\n * @param {?} name\n * @param {?} props\n * @param {?=} parentClass\n * @return {?}\n */\nexport function makeParamDecorator(\n  name: string, props: ([string, any] | { [name: string]: any })[], parentClass?: any): any {\n  const /** @type {?} */ metaCtor = makeMetadataCtor(props);\n/**\n * @param {...?} args\n * @return {?}\n */\nfunction ParamDecoratorFactory(...args: any[]): any {\n    if (this instanceof ParamDecoratorFactory) {\n      metaCtor.apply(this, args);\n      return this;\n    }\n    const /** @type {?} */ annotationInstance = new ( /** @type {?} */((<any>ParamDecoratorFactory)))(...args);\n\n    ( /** @type {?} */((<any>ParamDecorator))).annotation = annotationInstance;\n    return ParamDecorator;\n/**\n * @param {?} cls\n * @param {?} unusedKey\n * @param {?} index\n * @return {?}\n */\nfunction ParamDecorator(cls: any, unusedKey: any, index: number): any {\n      const /** @type {?} */ parameters: any[][] = Reflect.getOwnMetadata('parameters', cls) || [];\n\n      // there might be gaps if some in between parameters do not have annotations.\n      // we pad with nulls.\n      while (parameters.length <= index) {\n        parameters.push(null);\n      }\n\n      parameters[index] = parameters[index] || [];\n      parameters[index].push(annotationInstance);\n\n      Reflect.defineMetadata('parameters', parameters, cls);\n      return cls;\n    }\n  }\n  if (parentClass) {\n    ParamDecoratorFactory.prototype = Object.create(parentClass.prototype);\n  }\n  ParamDecoratorFactory.prototype.toString = () => `@${name}`;\n  ( /** @type {?} */((<any>ParamDecoratorFactory))).annotationCls = ParamDecoratorFactory;\n  return ParamDecoratorFactory;\n}\n/**\n * @param {?} name\n * @param {?} props\n * @param {?=} parentClass\n * @return {?}\n */\nexport function makePropDecorator(\n  name: string, props: ([string, any] | { [key: string]: any })[], parentClass?: any): any {\n  const /** @type {?} */ metaCtor = makeMetadataCtor(props);\n/**\n * @param {...?} args\n * @return {?}\n */\nfunction PropDecoratorFactory(...args: any[]): any {\n    if (this instanceof PropDecoratorFactory) {\n      metaCtor.apply(this, args);\n      return this;\n    }\n\n    const /** @type {?} */ decoratorInstance = new ( /** @type {?} */((<any>PropDecoratorFactory)))(...args);\n\n    // tslint:disable-next-line:no-shadowed-variable\n    return function PropDecorator(target: any, name: string) {\n      const /** @type {?} */ meta = Reflect.getOwnMetadata('propMetadata', target.constructor) || {};\n      meta[name] = meta.hasOwnProperty(name) && meta[name] || [];\n      meta[name].unshift(decoratorInstance);\n      Reflect.defineMetadata('propMetadata', meta, target.constructor);\n    };\n  }\n\n  if (parentClass) {\n    PropDecoratorFactory.prototype = Object.create(parentClass.prototype);\n  }\n\n  PropDecoratorFactory.prototype.toString = () => `@${name}`;\n  ( /** @type {?} */((<any>PropDecoratorFactory))).annotationCls = PropDecoratorFactory;\n  return PropDecoratorFactory;\n}\n"],"names":["ViewContainerRef_","prototype","remove","index","detach","ViewRef_","reattach","this","_view","state","onDestroy","callback","disposables","push","_appRef","detachView","attachToAppRef","appRef","attachToViewContainerRef","vcRef","Error","Injector_","get","token","notFoundValue","InjectionToken","_desc","result","Array","paramTypes","paramAnnotations","length","i","Object","parameters","parentCtor","tsickleCtorParams","ctorParameters","map","ctorParam","type","convertTsickleDecoratorIntoMetadata","decorators","_reflect","getOwnMetadata","ReflectionCapabilities","_ownAnnotations","typeOrFunc","annotations","propMetadata","propDecorators","propDecorators_1","propMetadata_1","isType","getParentCtor","parentPropMetadata_1","keys","forEach","propName","ownPropMetadata","_ownPropMetadata","__extends","Reflector","_super","updateCapabilities","caps","reflectionCapabilities","getter","name","setter","method","ComponentResolver","resolve","throwIfNotFound","resolved","_resolved","metadata","ListWrapper","findLast","_reflector","obj","Component","_mergeWithPropertyMetadata","meta","propertyMetadata","host","childs","hostListeners","filter","a","HostListener","hostListener","args","eventName","join","childListeners","ChildListener","childListener","selector","StringMapWrapper","merge","BaseError","message","stack","defineProperty","WrappedError","originalError","_nativeError","first","stringify","NoProviderError","call","injector","key","CyclicDependencyError","NoAnnotationError","_genMessage","params","signature","ii","parameter","MixingMultiProvidersWithRegularProvidersError","provider1","provider2","_globalKeyRegistry","numberOfKeys","_allKeys","has","ResolvedReflectiveFactory","factory","dependencies","ReflectiveInjector_","_providers","_parent","_constructionCounter","_instantiateProvider","provider","_getMaxNumberOfObjects","objs","multiProvider","_instantiate","ResolvedReflectiveFactory$$1","deps","_this","dep","_getByReflectiveDependency","e","AbstractProviderError","InstantiationError","addKey","_getByKey","visibility","_getByKeySelf","_getObjByKeyId","keyId","_getByKeyDefault","inj","SkipSelf","inj_","id","UNDEFINED","PlatformRef","destroy","ComponentFactoryResolver","resolveComponentFactory","componentType","_factories","CouldNotResolveFactoryError","ApplicationRef","bootstrap","componentOrFactory","componentFactory","ComponentFactory","_rootComponentTypes","_rootComponents","componentRef","_views","slice","view","Injectable","ElementRef","ViewContainerRef","anchorElement","NodeData","_tokenKeyCache","Map","InjectorRefTokenKey","tokenKey","Injector","VIEW_DEFINITION_CACHE","WeakMap","_component","configurable","ComponentRef_","_viewRef","def","clear","viewRef_","resolveForwardRef","resolveReflectiveFactory","factoryFn","resolvedDeps","useClass","reflector","_dependenciesFor","useExisting","aliasInstance","ReflectiveDependency","fromKey","ReflectiveKey","mergeResolvedReflectiveProviders","providers","normalizedProvidersMap","existing","j","resolvedFactories","set","resolvedProvider","_normalizeProviders","res","b","Function","provide","undefined","_extractToken","optional","isArray","Inject","_createDependency","paramMetadata","Optional","Self","createPlatformFactory","extraProviders","ReflectiveInjector","resolveAndCreate","concat","asProviderData","nodes","resolveDep","depDef","allowPrivateServices","THROW_IF_NOT_FOUND","flags","startView","parent","RendererTokenKey","viewContainer","viewContainerParent","createInjector","providerDef","allProviders","publicProviders","providerData","instance","NOT_CREATED","createView","root","renderElement","renderer","createRenderer","context","createViewNodes","nodeData","nodeDef","createProviderInstance","createRootData","rendererFactory","rootSelectorOrNode","element","viewDef","componentProvider","publicProv","create","resolvedFactory","p","resolvedComp","resolveReflectiveProviders","hostElement","parentView","rendererType","componentRendererType","detachEmbeddedView","viewIndex","embeddedViews","_embeddedViews","removeFromArray","arr","resolveViewDefinition","value","globalScope","m1","m2","equals","k1","k2","window","WorkerGlobalScope","self","findFirstClosedCycle","reversed","reverse","overriddenName","getClassName","HTMLElement","parts","toString","match","newLineIndex","indexOf","DecoratorFactory","objOrType","metaCtor","annotationInstance","chainAnnotation","TypeDecorator","cls","Reflect","defineMetadata","chainFn","makeMetadataCtor","props","parentClass","_i","arguments","prop","argVal","ParamDecoratorFactory","ParamDecorator","unusedKey","apply","decoratorInstance","bind","target","constructor","hasOwnProperty","unshift","decoratorInvocations","decoratorType","decoratorInvocation"],"mappings":"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"}